# Installing a cluster on AWS in a restricted network with user-provisioned infrastructure


In Red Hat OpenShift Container Platform version 4.15, you can install a
cluster on Amazon Web Services (AWS) using infrastructure that you provide and
an internal mirror of the installation release content.

[IMPORTANT]
----
While you can install an Red Hat OpenShift Container Platform cluster by using mirrored installation
release content, your cluster still requires internet access to use the AWS APIs.
----
One way to create this infrastructure is to use the provided
CloudFormation templates. You can modify the templates to customize your
infrastructure or use the information that they contain to create AWS objects
according to your company's policies.

[IMPORTANT]
----
The steps for performing a user-provisioned infrastructure installation are provided as an example only. Installing a cluster with infrastructure you provide requires knowledge of the cloud provider and the installation process of Red Hat OpenShift Container Platform. Several CloudFormation templates are provided to assist in completing these steps or to help model your own. You are also free to create the required resources through other methods; the templates are just an example.
----

# Prerequisites

* You reviewed details about the Red Hat OpenShift Container Platform installation and update processes.
* You read the documentation on selecting a cluster installation method and preparing it for users.
* You created a mirror registry on your mirror host and obtained the imageContentSources data for your version of Red Hat OpenShift Container Platform.

[IMPORTANT]
----
Because the installation media is on the mirror host, you can use that computer to complete all installation steps.
----
* You configured an AWS account to host the cluster.

[IMPORTANT]
----
If you have an AWS profile stored on your computer, it must not use a temporary session token that you generated while using a multi-factor authentication device. The cluster continues to use your current AWS credentials to create AWS resources for the entire life of the cluster, so you must use key-based, long-term credentials. To generate appropriate keys, see Managing Access Keys for IAM Users in the AWS documentation. You can supply the keys when you run the installation program.
----
* You downloaded the AWS CLI and installed it on your computer. See Install the AWS CLI Using the Bundled Installer (Linux, macOS, or Unix) in the AWS documentation.
* If you use a firewall and plan to use the Telemetry service, you configured the firewall to allow the sites that your cluster requires access to.

[NOTE]
----
Be sure to also review this site list if you are configuring a proxy.
----
* If the cloud identity and access management (IAM) APIs are not accessible in your environment, or if you do not want to store an administrator-level credential secret in the kube-system namespace, you can manually create and maintain long-term credentials.

# About installations in restricted networks

In Red Hat OpenShift Container Platform 4.15, you can perform an installation that does not
require an active connection to the internet to obtain software components. Restricted network installations can be completed using installer-provisioned infrastructure or user-provisioned infrastructure, depending on the cloud platform to which you are installing the cluster.

If you choose to perform a restricted network installation on a cloud platform, you
still require access to its cloud APIs. Some cloud functions, like
Amazon Web Service&#8217;s Route 53 DNS and IAM services, require internet access.
Depending on your network, you might require less internet
access for an installation on bare metal hardware, Nutanix, or on VMware vSphere.

To complete a restricted network installation, you must create a registry that
mirrors the contents of the OpenShift image registry and contains the
installation media. You can create this registry on a mirror host, which can
access both the internet and your closed network, or by using other methods
that meet your restrictions.


[IMPORTANT]
----
Because of the complexity of the configuration for user-provisioned installations, consider completing a standard user-provisioned infrastructure installation before you attempt a restricted network installation using user-provisioned infrastructure. Completing this test installation might make it easier to isolate and troubleshoot any issues that might arise during your installation in a restricted network.
----

## Additional limits

Clusters in restricted networks have the following additional limitations and restrictions:

* The ClusterVersion status includes an Unable to retrieve available updates
error.
* By default, you cannot use the contents of the Developer Catalog because
you cannot access the required image stream tags.

# Internet access for Red Hat OpenShift Container Platform

In Red Hat OpenShift Container Platform 4.15, you require access to the internet to
obtain the images that are necessary to install
your cluster.

You must have internet access to:

* Access https://console.redhat.com/openshift [OpenShift Cluster Manager] to download the installation program and perform subscription management. If the cluster has internet access and you do not disable Telemetry, that service automatically entitles your cluster.
* Access Quay.io to obtain the packages that are required to install your cluster.
* Obtain the packages that are required to perform cluster updates.

# Requirements for a cluster with user-provisioned infrastructure

For a cluster that contains user-provisioned infrastructure, you must deploy all
of the required machines.

This section describes the requirements for deploying Red Hat OpenShift Container Platform on user-provisioned infrastructure.

## Required machines for cluster installation

The smallest Red Hat OpenShift Container Platform clusters require the following hosts:




[IMPORTANT]
----
To maintain high availability of your cluster, use separate physical hosts for
these cluster machines.
----

The bootstrap and control plane machines must use Red Hat Enterprise Linux CoreOS (RHCOS) as the operating system. However, the compute machines can choose between Red Hat Enterprise Linux CoreOS (RHCOS), Red Hat Enterprise Linux (RHEL) 8.6 and later.

Note that RHCOS is based on Red Hat Enterprise Linux (RHEL) 9.2 and inherits all of its hardware certifications and requirements.
See Red Hat Enterprise Linux technology capabilities and limits.

## Minimum resource requirements for cluster installation

Each cluster machine must meet the following minimum requirements:



1. One vCPU is equivalent to one physical core when simultaneous multithreading (SMT), or hyperthreading, is not enabled. When enabled, use the following formula to calculate the corresponding ratio: (threads per core × cores) × sockets = vCPUs.
2. Red Hat OpenShift Container Platform and Kubernetes are sensitive to disk performance, and faster storage is recommended, particularly for etcd on the control plane nodes which require a 10 ms p99 fsync duration. Note that on many cloud platforms, storage size and IOPS scale together, so you might need to over-allocate storage volume to obtain sufficient performance.
3. As with all user-provisioned installations, if you choose to use RHEL compute machines in your cluster, you take responsibility for all operating system life cycle management and maintenance, including performing system updates, applying patches, and completing all other required tasks. Use of RHEL 7 compute machines is deprecated and has been removed in Red Hat OpenShift Container Platform 4.10 and later.


[NOTE]
----
As of Red Hat OpenShift Container Platform version 4.13, RHCOS is based on RHEL version 9.2, which updates the micro-architecture requirements. The following list contains the minimum instruction set architectures (ISA) that each architecture requires:
* x86-64 architecture requires x86-64-v2 ISA
* ARM64 architecture requires ARMv8.0-A ISA
* IBM Power architecture requires Power 9 ISA
* s390x architecture requires z14 ISA
For more information, see RHEL Architectures.
----

If an instance type for your platform meets the minimum requirements for cluster machines, it is supported to use in Red Hat OpenShift Container Platform.

* Optimizing storage

## Tested instance types for AWS

The following Amazon Web Services (AWS) instance types have been tested with
Red Hat OpenShift Container Platform.


[NOTE]
----
Use the machine types included in the following charts for your AWS instances. If you use an instance type that is not listed in the chart, ensure that the instance size you use matches the minimum resource requirements that are listed in the section named "Minimum resource requirements for cluster installation".
----

https://raw.githubusercontent.com/openshift/installer/master/docs/user/aws/tested_instance_types_x86_64.md

## Tested instance types for AWS on 64-bit ARM infrastructures

The following Amazon Web Services (AWS) 64-bit ARM instance types have been tested with Red Hat OpenShift Container Platform.


[NOTE]
----
Use the machine types included in the following charts for your AWS ARM instances. If you use an instance type that is not listed in the chart, ensure that the instance size you use matches the minimum resource requirements that are listed in "Minimum resource requirements for cluster installation".
----

https://raw.githubusercontent.com/openshift/installer/master/docs/user/aws/tested_instance_types_aarch64.md

## Certificate signing requests management

Because your cluster has limited access to automatic machine management when you use infrastructure that you provision, you must provide a mechanism for approving cluster certificate signing requests (CSRs) after installation. The kube-controller-manager only approves the kubelet client CSRs. The machine-approver cannot guarantee the validity of a serving certificate that is requested by using kubelet credentials because it cannot confirm that the correct machine issued the request. You must determine and implement a method of verifying the validity of the kubelet serving certificate requests and approving them.

# Required AWS infrastructure components

To install Red Hat OpenShift Container Platform on user-provisioned infrastructure in Amazon Web Services (AWS), you must manually create both the machines and their supporting infrastructure.

For more information about the integration testing for different platforms, see the OpenShift Container Platform 4.x Tested Integrations page.

By using the provided CloudFormation templates, you can create stacks of AWS resources that represent the following components:

* An AWS Virtual Private Cloud (VPC)
* Networking and load balancing components
* Security groups and roles
* An Red Hat OpenShift Container Platform bootstrap node
* Red Hat OpenShift Container Platform control plane nodes
* An Red Hat OpenShift Container Platform compute node

Alternatively, you can manually create the components or you can reuse existing infrastructure that meets the cluster requirements. Review the CloudFormation templates for more details about how the components interrelate.

## Other infrastructure components

* A VPC
* DNS entries
* Load balancers (classic or network) and listeners
* A public and a private Route 53 zone
* Security groups
* IAM roles
* S3 buckets

If you are working in a disconnected environment, you are unable to reach the public IP addresses for EC2, ELB, and S3 endpoints. Depending on the level to which you want to restrict internet traffic during the installation, the following configuration options are available:

## Option 1: Create VPC endpoints

Create a VPC endpoint and attach it to the subnets that the clusters are using. Name the endpoints as follows:

* ec2.<aws_region>.amazonaws.com
* elasticloadbalancing.<aws_region>.amazonaws.com
* s3.<aws_region>.amazonaws.com

With this option, network traffic remains private between your VPC and the required AWS services.

## Option 2: Create a proxy without VPC endpoints

As part of the installation process, you can configure an HTTP or HTTPS proxy. With this option, internet traffic goes through the proxy to reach the required AWS services.

## Option 3: Create a proxy with VPC endpoints

As part of the installation process, you can configure an HTTP or HTTPS proxy with VPC endpoints. Create a VPC endpoint and attach it to the subnets that the clusters are using. Name the endpoints as follows:

* ec2.<aws_region>.amazonaws.com
* elasticloadbalancing.<aws_region>.amazonaws.com
* s3.<aws_region>.amazonaws.com

When configuring the proxy in the install-config.yaml file, add these endpoints to the noProxy field. With this option, the proxy prevents the cluster from accessing the internet directly. However, network traffic remains private between your VPC and the required AWS services.

You must provide a suitable VPC and subnets that allow communication to your
machines.



Your DNS and load balancer configuration needs to use a public hosted zone and
can use a private hosted zone similar to the one that the installation program
uses if it provisions the cluster&#8217;s infrastructure. You must
create a DNS entry that resolves to your load balancer. An entry for
api.<cluster_name>.<domain> must point to the external load balancer, and an
entry for api-int.<cluster_name>.<domain> must point to the internal load
balancer.

The cluster also requires load balancers and listeners for port 6443, which are
required for the Kubernetes API and its extensions, and port 22623, which are
required for the Ignition config files for new machines. The targets will be the
control plane nodes. Port 6443 must be accessible to both clients external to the
cluster and nodes within the cluster. Port 22623 must be accessible to nodes
within the cluster.



The control plane and worker machines require access to the following ports:



The control plane machines require the following Ingress groups. Each Ingress group is
a AWS::EC2::SecurityGroupIngress resource.



The worker machines require the following Ingress groups. Each Ingress group is
a AWS::EC2::SecurityGroupIngress resource.



You must grant the machines permissions in AWS. The provided CloudFormation
templates grant the machines Allow permissions for the following AWS::IAM::Role objects
and provide a AWS::IAM::InstanceProfile for each set of roles. If you do
not use the templates, you can grant the machines the following broad permissions
or the following individual permissions.



## Cluster machines

You need AWS::EC2::Instance objects for the following machines:

* A bootstrap machine. This machine is required during installation, but you can remove it after your cluster deploys.
* Three control plane machines. The control plane machines are not governed by a control plane machine set.
* Compute machines. You must create at least two compute machines, which are also known as worker machines, during installation. These machines are not governed by a compute machine set.

## Required AWS permissions for the IAM user


[NOTE]
----
Your IAM user must have the permission tag:GetResources in the region us-east-1 to delete the base cluster resources. As part of the AWS API requirement, the Red Hat OpenShift Container Platform installation program performs various actions in this region.
----

When you attach the AdministratorAccess policy to the IAM user that you create in Amazon Web Services (AWS),
you grant that user all of the required permissions. To deploy all components of an Red Hat OpenShift Container Platform
cluster, the IAM user requires the following permissions:

* ec2:AttachNetworkInterface
* ec2:AuthorizeSecurityGroupEgress
* ec2:AuthorizeSecurityGroupIngress
* ec2:CopyImage
* ec2:CreateNetworkInterface
* ec2:CreateSecurityGroup
* ec2:CreateTags
* ec2:CreateVolume
* ec2:DeleteSecurityGroup
* ec2:DeleteSnapshot
* ec2:DeleteTags
* ec2:DeregisterImage
* ec2:DescribeAccountAttributes
* ec2:DescribeAddresses
* ec2:DescribeAvailabilityZones
* ec2:DescribeDhcpOptions
* ec2:DescribeImages
* ec2:DescribeInstanceAttribute
* ec2:DescribeInstanceCreditSpecifications
* ec2:DescribeInstances
* ec2:DescribeInstanceTypes
* ec2:DescribeInternetGateways
* ec2:DescribeKeyPairs
* ec2:DescribeNatGateways
* ec2:DescribeNetworkAcls
* ec2:DescribeNetworkInterfaces
* ec2:DescribePrefixLists
* ec2:DescribeRegions
* ec2:DescribeRouteTables
* ec2:DescribeSecurityGroupRules
* ec2:DescribeSecurityGroups
* ec2:DescribeSubnets
* ec2:DescribeTags
* ec2:DescribeVolumes
* ec2:DescribeVpcAttribute
* ec2:DescribeVpcClassicLink
* ec2:DescribeVpcClassicLinkDnsSupport
* ec2:DescribeVpcEndpoints
* ec2:DescribeVpcs
* ec2:GetEbsDefaultKmsKeyId
* ec2:ModifyInstanceAttribute
* ec2:ModifyNetworkInterfaceAttribute
* ec2:RevokeSecurityGroupEgress
* ec2:RevokeSecurityGroupIngress
* ec2:RunInstances
* ec2:TerminateInstances

* ec2:AllocateAddress
* ec2:AssociateAddress
* ec2:AssociateDhcpOptions
* ec2:AssociateRouteTable
* ec2:AttachInternetGateway
* ec2:CreateDhcpOptions
* ec2:CreateInternetGateway
* ec2:CreateNatGateway
* ec2:CreateRoute
* ec2:CreateRouteTable
* ec2:CreateSubnet
* ec2:CreateVpc
* ec2:CreateVpcEndpoint
* ec2:ModifySubnetAttribute
* ec2:ModifyVpcAttribute

[NOTE]
----
If you use an existing Virtual Private Cloud (VPC), your account does not require these permissions for creating network resources.
----

* elasticloadbalancing:AddTags
* elasticloadbalancing:ApplySecurityGroupsToLoadBalancer
* elasticloadbalancing:AttachLoadBalancerToSubnets
* elasticloadbalancing:ConfigureHealthCheck
* elasticloadbalancing:CreateListener
* elasticloadbalancing:CreateLoadBalancer
* elasticloadbalancing:CreateLoadBalancerListeners
* elasticloadbalancing:CreateTargetGroup
* elasticloadbalancing:DeleteLoadBalancer
* elasticloadbalancing:DeregisterInstancesFromLoadBalancer
* elasticloadbalancing:DeregisterTargets
* elasticloadbalancing:DescribeInstanceHealth
* elasticloadbalancing:DescribeListeners
* elasticloadbalancing:DescribeLoadBalancerAttributes
* elasticloadbalancing:DescribeLoadBalancers
* elasticloadbalancing:DescribeTags
* elasticloadbalancing:DescribeTargetGroupAttributes
* elasticloadbalancing:DescribeTargetHealth
* elasticloadbalancing:ModifyLoadBalancerAttributes
* elasticloadbalancing:ModifyTargetGroup
* elasticloadbalancing:ModifyTargetGroupAttributes
* elasticloadbalancing:RegisterInstancesWithLoadBalancer
* elasticloadbalancing:RegisterTargets
* elasticloadbalancing:SetLoadBalancerPoliciesOfListener

[IMPORTANT]
----
Red Hat OpenShift Container Platform uses both the ELB and ELBv2 API services to provision load balancers. The permission list shows permissions required by both services. A known issue exists in the AWS web console where both services use the same elasticloadbalancing action prefix but do not recognize the same actions. You can ignore the warnings about the service not recognizing certain elasticloadbalancing actions.
----

* iam:AddRoleToInstanceProfile
* iam:CreateInstanceProfile
* iam:CreateRole
* iam:DeleteInstanceProfile
* iam:DeleteRole
* iam:DeleteRolePolicy
* iam:GetInstanceProfile
* iam:GetRole
* iam:GetRolePolicy
* iam:GetUser
* iam:ListInstanceProfilesForRole
* iam:ListRoles
* iam:ListUsers
* iam:PassRole
* iam:PutRolePolicy
* iam:RemoveRoleFromInstanceProfile
* iam:SimulatePrincipalPolicy
* iam:TagInstanceProfile
* iam:TagRole

[NOTE]
----
If you have not created a load balancer in your AWS account, the IAM user also requires the iam:CreateServiceLinkedRole permission.
----

* route53:ChangeResourceRecordSets
* route53:ChangeTagsForResource
* route53:CreateHostedZone
* route53:DeleteHostedZone
* route53:GetChange
* route53:GetHostedZone
* route53:ListHostedZones
* route53:ListHostedZonesByName
* route53:ListResourceRecordSets
* route53:ListTagsForResource
* route53:UpdateHostedZoneComment

* s3:CreateBucket
* s3:DeleteBucket
* s3:GetAccelerateConfiguration
* s3:GetBucketAcl
* s3:GetBucketCors
* s3:GetBucketLocation
* s3:GetBucketLogging
* s3:GetBucketObjectLockConfiguration
* s3:GetBucketPolicy
* s3:GetBucketRequestPayment
* s3:GetBucketTagging
* s3:GetBucketVersioning
* s3:GetBucketWebsite
* s3:GetEncryptionConfiguration
* s3:GetLifecycleConfiguration
* s3:GetReplicationConfiguration
* s3:ListBucket
* s3:PutBucketAcl
* s3:PutBucketTagging
* s3:PutEncryptionConfiguration

* s3:DeleteObject
* s3:GetObject
* s3:GetObjectAcl
* s3:GetObjectTagging
* s3:GetObjectVersion
* s3:PutObject
* s3:PutObjectAcl
* s3:PutObjectTagging

* autoscaling:DescribeAutoScalingGroups
* ec2:DeleteNetworkInterface
* ec2:DeletePlacementGroup
* ec2:DeleteVolume
* elasticloadbalancing:DeleteTargetGroup
* elasticloadbalancing:DescribeTargetGroups
* iam:DeleteAccessKey
* iam:DeleteUser
* iam:DeleteUserPolicy
* iam:ListAttachedRolePolicies
* iam:ListInstanceProfiles
* iam:ListRolePolicies
* iam:ListUserPolicies
* s3:DeleteObject
* s3:ListBucketVersions
* tag:GetResources

* ec2:DeleteDhcpOptions
* ec2:DeleteInternetGateway
* ec2:DeleteNatGateway
* ec2:DeleteRoute
* ec2:DeleteRouteTable
* ec2:DeleteSubnet
* ec2:DeleteVpc
* ec2:DeleteVpcEndpoints
* ec2:DetachInternetGateway
* ec2:DisassociateRouteTable
* ec2:ReleaseAddress
* ec2:ReplaceRouteTableAssociation

[NOTE]
----
If you use an existing VPC, your account does not require these permissions to delete network resources. Instead, your account only requires the tag:UntagResources permission to delete network resources.
----

* kms:CreateGrant
* kms:Decrypt
* kms:DescribeKey
* kms:Encrypt
* kms:GenerateDataKey
* kms:GenerateDataKeyWithoutPlainText
* kms:ListGrants
* kms:RevokeGrant

* iam:UntagRole

* iam:GetUserPolicy
* iam:ListAccessKeys
* iam:PutUserPolicy
* iam:TagUser
* s3:AbortMultipartUpload
* s3:GetBucketPublicAccessBlock
* s3:ListBucket
* s3:ListBucketMultipartUploads
* s3:PutBucketPublicAccessBlock
* s3:PutLifecycleConfiguration

[NOTE]
----
If you are managing your cloud provider credentials with mint mode, the IAM user also requires the iam:CreateAccessKey and iam:CreateUser permissions.
----

* ec2:DescribeInstanceTypeOfferings
* servicequotas:ListAWSDefaultServiceQuotas

* sts:AssumeRole

# Generating a key pair for cluster node SSH access

During an Red Hat OpenShift Container Platform installation, you can provide an SSH public key to the installation program. The key is passed to the Red Hat Enterprise Linux CoreOS (RHCOS) nodes through their Ignition config files and is used to authenticate SSH access to the nodes. The key is added to the ~/.ssh/authorized_keys list for the core user on each node, which enables password-less authentication.

After the key is passed to the nodes, you can use the key pair to SSH in to the RHCOS nodes as the user core. To access the nodes through SSH, the private key identity must be managed by SSH for your local user.

If you want to SSH in to your cluster nodes to perform installation debugging or disaster recovery, you must provide the SSH public key during the installation process. The ./openshift-install gather command also requires the SSH public key to be in place on the cluster nodes.


[IMPORTANT]
----
Do not skip this procedure in production environments, where disaster recovery and debugging is required.
----


[NOTE]
----
You must use a local key, not one that you configured with platform-specific
approaches such as
AWS key pairs.
----

1. If you do not have an existing SSH key pair on your local machine to use for authentication onto your cluster nodes, create one. For example, on a computer that uses a Linux operating system, run the following command:

```terminal
$ ssh-keygen -t ed25519 -N '' -f <path>/<file_name> 1
```

Specify the path and file name, such as ~/.ssh/id_ed25519, of the new SSH key. If you have an existing key pair, ensure your public key is in the your ~/.ssh directory.

[NOTE]
----
If you plan to install an Red Hat OpenShift Container Platform cluster that uses the RHEL cryptographic libraries that have been submitted to NIST for FIPS 140-2/140-3 Validation on only the x86_64, ppc64le, and s390x architectures, do not create a key that uses the ed25519 algorithm. Instead, create a key that uses the rsa or ecdsa algorithm.
----
2. View the public SSH key:

```terminal
$ cat <path>/<file_name>.pub
```


For example, run the following to view the ~/.ssh/id_ed25519.pub public key:

```termanal
$ cat ~/.ssh/id_ed25519.pub
```

3. Add the SSH private key identity to the SSH agent for your local user, if it has not already been added. SSH agent management of the key is required for password-less SSH authentication onto your cluster nodes, or if you want to use the ./openshift-install gather command.

[NOTE]
----
On some distributions, default SSH private key identities such as ~/.ssh/id_rsa and ~/.ssh/id_dsa are managed automatically.
----
1. If the ssh-agent process is not already running for your local user, start it as a background task:

```terminal
$ eval "$(ssh-agent -s)"
```

Example output

```terminal
Agent pid 31874
```


[NOTE]
----
If your cluster is in FIPS mode, only use FIPS-compliant algorithms to generate the SSH key. The key must be either RSA or ECDSA.
----
4. Add your SSH private key to the ssh-agent:

```terminal
$ ssh-add <path>/<file_name> 1
```

Specify the path and file name for your SSH private key, such as ~/.ssh/id_ed25519
Example output

```terminal
Identity added: /home/<you>/<path>/<file_name> (<computer_name>)
```


* When you install Red Hat OpenShift Container Platform, provide the SSH public key to the installation program.
If you install a cluster on infrastructure that you provision, you must provide the key to the installation program.

# Creating the installation files for AWS

To install Red Hat OpenShift Container Platform on {cp-first} ({cp}) using user-provisioned infrastructure, you must generate the files that the installation program needs to deploy your cluster and modify them so that the cluster creates only the machines that it will use. You generate and customize the install-config.yaml file, Kubernetes manifests, and Ignition config files. You also have the option to first set up a separate var partition during the preparation phases of installation.

## Optional: Creating a separate /var partition

It is recommended that disk partitioning for Red Hat OpenShift Container Platform be left to the installer. However, there are cases where you might want to create separate partitions in a part of the filesystem that you expect to grow.

Red Hat OpenShift Container Platform supports the addition of a single partition to attach storage to either the /var partition or a subdirectory of /var. For example:

* /var/lib/containers: Holds container-related content that can grow as more images and containers are added to a system.
* /var/lib/etcd: Holds data that you might want to keep separate for purposes such as performance optimization of etcd storage.
* /var: Holds data that you might want to keep separate for purposes such as auditing.

Storing the contents of a /var directory separately makes it easier to grow storage for those areas as needed and reinstall Red Hat OpenShift Container Platform at a later date and keep that data intact. With this method, you will not have to pull all your containers again, nor will you have to copy massive log files when you update systems.

Because /var must be in place before a fresh installation of Red Hat Enterprise Linux CoreOS (RHCOS), the following procedure sets up the separate /var partition by creating a machine config manifest that is inserted during the openshift-install preparation phases of an Red Hat OpenShift Container Platform installation.


[IMPORTANT]
----
If you follow the steps to create a separate /var partition in this procedure, it is not necessary to create the Kubernetes manifest and Ignition config files again as described later in this section.
----

1. Create a directory to hold the Red Hat OpenShift Container Platform installation files:

```terminal
$ mkdir $HOME/clusterconfig
```

2. Run openshift-install to create a set of files in the manifest and openshift subdirectories. Answer the system questions as you are prompted:

```terminal
$ openshift-install create manifests --dir $HOME/clusterconfig
```

Example output

```terminal
? SSH Public Key ...
INFO Credentials loaded from the "myprofile" profile in file "/home/myuser/.aws/credentials"
INFO Consuming Install Config from target directory
INFO Manifests created in: $HOME/clusterconfig/manifests and $HOME/clusterconfig/openshift
```

3. Optional: Confirm that the installation program created manifests in the clusterconfig/openshift directory:

```terminal
$ ls $HOME/clusterconfig/openshift/
```

Example output

```terminal
99_kubeadmin-password-secret.yaml
99_openshift-cluster-api_master-machines-0.yaml
99_openshift-cluster-api_master-machines-1.yaml
99_openshift-cluster-api_master-machines-2.yaml
...
```

4. Create a Butane config that configures the additional partition. For example, name the file $HOME/clusterconfig/98-var-partition.bu, change the disk device name to the name of the storage device on the worker systems, and set the storage size as appropriate. This example places the /var directory on a separate partition:

```yaml
variant: openshift
version: 4.15.0
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 98-var-partition
storage:
  disks:
  - device: /dev/disk/by-id/<device_name> 1
    partitions:
    - label: var
      start_mib: <partition_start_offset> 2
      size_mib: <partition_size> 3
      number: 5
  filesystems:
    - device: /dev/disk/by-partlabel/var
      path: /var
      format: xfs
      mount_options: [defaults, prjquota] 4
      with_mount_unit: true
```

The storage device name of the disk that you want to partition.
When adding a data partition to the boot disk, a minimum value of 25000 MiB (Mebibytes) is recommended. The root file system is automatically resized to fill all available space up to the specified offset. If no value is specified, or if the specified value is smaller than the recommended minimum, the resulting root file system will be too small, and future reinstalls of RHCOS might overwrite the beginning of the data partition.
The size of the data partition in mebibytes.
The prjquota mount option must be enabled for filesystems used for container storage.

[NOTE]
----
When creating a separate /var partition, you cannot use different instance types for worker nodes, if the different instance types do not have the same device name.
----
5. Create a manifest from the Butane config and save it to the clusterconfig/openshift directory. For example, run the following command:

```terminal
$ butane $HOME/clusterconfig/98-var-partition.bu -o $HOME/clusterconfig/openshift/98-var-partition.yaml
```

6. Run openshift-install again to create Ignition configs from a set of files in the manifest and openshift subdirectories:

```terminal
$ openshift-install create ignition-configs --dir $HOME/clusterconfig
$ ls $HOME/clusterconfig/
auth  bootstrap.ign  master.ign  metadata.json  worker.ign
```


Now you can use the Ignition config files as input to the installation procedures to install Red Hat Enterprise Linux CoreOS (RHCOS) systems.

## Creating the installation configuration file

Generate and customize the installation configuration file that the
installation program needs to deploy your cluster.

* You obtained the Red Hat OpenShift Container Platform installation program
for user-provisioned infrastructure
and the pull secret for your cluster.
For a restricted network installation, these files are on your mirror host.
* You checked that you are deploying your cluster to an AWS Region with an accompanying Red Hat Enterprise Linux CoreOS (RHCOS) AMI published by Red Hat. If you are deploying to an AWS Region that requires a custom AMI, such as an AWS GovCloud Region, you must create the install-config.yaml file manually.

1. Create the install-config.yaml file.
1. Change to the directory that contains the installation program and run the following command:

```terminal
$ ./openshift-install create install-config --dir <installation_directory> 1
```

For <installation_directory>, specify the directory name to store the
files that the installation program creates.

[IMPORTANT]
----
Specify an empty directory. Some installation assets, like bootstrap X.509
certificates have short expiration intervals, so you must not reuse an
installation directory. If you want to reuse individual files from another
cluster installation, you can copy them into your directory. However, the file
names for the installation assets might change between releases. Use caution
when copying installation files from an earlier Red Hat OpenShift Container Platform version.
----
2. At the prompts, provide the configuration details for your cloud:
1. Optional: Select an SSH key to use to access your cluster machines.

[NOTE]
----
For production Red Hat OpenShift Container Platform clusters on which you want to perform installation debugging or disaster recovery, specify an SSH key that your ssh-agent process uses.
----
2. Select aws as the platform to target.
3. If you do not have an AWS profile stored on your computer, enter the AWS
access key ID and secret access key for the user that you configured to run the
installation program.

[NOTE]
----
The AWS access key ID and secret access key are stored in ~/.aws/credentials in the home directory of the current user on the installation host. You are prompted for the credentials by the installation program if the credentials for the exported profile are not present in the file. Any credentials that you provide to the installation program are stored in the file.
----
4. Select the AWS Region to deploy the cluster to.
5. Select the base domain for the Route 53 service that you configured for your cluster.
6. Enter a descriptive name for your cluster.
7. Paste the https://console.redhat.com/openshift/install/pull-secret [pull secret from Red Hat OpenShift Cluster Manager].
2. Edit the install-config.yaml file to give the additional information that
is required for an installation in a restricted network.
1. Update the pullSecret value to contain the authentication information for
your registry:

```yaml
pullSecret: '{"auths":{"<local_registry>": {"auth": "<credentials>","email": "you@example.com"}}}'
```


For <local_registry>, specify the registry domain name, and optionally the
port, that your mirror registry uses to serve content. For example
registry.example.com or registry.example.com:5000. For <credentials>,
specify the base64-encoded user name and password for your mirror registry.
2. Add the additionalTrustBundle parameter and value. The value must be the contents of the certificate file that you used for your mirror registry. The certificate file can be an existing, trusted certificate authority or the self-signed certificate that you generated for the mirror registry.

```yaml
additionalTrustBundle: |
  -----BEGIN CERTIFICATE-----
  ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
  -----END CERTIFICATE-----
```

3. Add the image content resources:

```yaml
imageContentSources:
- mirrors:
  - <local_registry>/<local_repository_name>/release
  source: quay.io/openshift-release-dev/ocp-release
- mirrors:
  - <local_registry>/<local_repository_name>/release
  source: quay.io/openshift-release-dev/ocp-v4.0-art-dev
```


Use the imageContentSources section from the output of the command to mirror the repository or the values that you used when you mirrored the content from the media that you brought into your restricted network.
4. Optional: Set the publishing strategy to Internal:

```yaml
publish: Internal
```


By setting this option, you create an internal Ingress Controller and a private load balancer.
3. Optional: Back up the install-config.yaml file.

[IMPORTANT]
----
The install-config.yaml file is consumed during the installation process. If
you want to reuse the file, you must back it up now.
----

* See Configuration and credential file settings in the AWS documentation for more information about AWS profile and credential configuration.

## Configuring the cluster-wide proxy during installation

Production environments can deny direct access to the internet and instead have
an HTTP or HTTPS proxy available. You can configure a new Red Hat OpenShift Container Platform
cluster to use a proxy by configuring the proxy settings in the
install-config.yaml file.

* You have an existing install-config.yaml file.
* You reviewed the sites that your cluster requires access to and determined whether any of them need to bypass the proxy. By default, all cluster egress traffic is proxied, including calls to hosting cloud provider APIs. You added sites to the Proxy object's spec.noProxy field to bypass the proxy if necessary.

[NOTE]
----
The Proxy object status.noProxy field is populated with the values of the networking.machineNetwork[].cidr, networking.clusterNetwork[].cidr, and networking.serviceNetwork[] fields from your installation configuration.
For installations on Amazon Web Services (AWS), Google Cloud Platform (GCP), Microsoft Azure, and Red Hat OpenStack Platform (RHOSP), the Proxy object status.noProxy field is also populated with the instance metadata endpoint (169.254.169.254).
----

1. Edit your install-config.yaml file and add the proxy settings. For example:

```yaml
apiVersion: v1
baseDomain: my.domain.com
proxy:
  httpProxy: http://<username>:<pswd>@<ip>:<port> 1
  httpsProxy: https://<username>:<pswd>@<ip>:<port> 2
  noProxy: ec2.<aws_region>.amazonaws.com,elasticloadbalancing.<aws_region>.amazonaws.com,s3.<aws_region>.amazonaws.com 3
additionalTrustBundle: | 4
    -----BEGIN CERTIFICATE-----
    <MY_TRUSTED_CA_CERT>
    -----END CERTIFICATE-----
additionalTrustBundlePolicy: <policy_to_add_additionalTrustBundle> 5
```

A proxy URL to use for creating HTTP connections outside the cluster. The
URL scheme must be http.
A proxy URL to use for creating HTTPS connections outside the cluster.
A comma-separated list of destination domain names, IP addresses, or other network CIDRs to exclude from proxying. Preface a domain with . to match subdomains only. For example, .y.com matches x.y.com, but not y.com. Use * to bypass the proxy for all destinations.
If you have added the Amazon EC2,Elastic Load Balancing, and S3 VPC endpoints to your VPC, you must add these endpoints to the noProxy field.
If provided, the installation program generates a config map that is named user-ca-bundle in
the openshift-config namespace that contains one or more additional CA
certificates that are required for proxying HTTPS connections. The Cluster Network
Operator then creates a trusted-ca-bundle config map that merges these contents
with the Red Hat Enterprise Linux CoreOS (RHCOS) trust bundle, and this config map is referenced in the trustedCA field of the Proxy object. The additionalTrustBundle field is required unless
the proxy's identity certificate is signed by an authority from the RHCOS trust
bundle.
Optional: The policy to determine the configuration of the Proxy object to reference the user-ca-bundle config map in the trustedCA field. The allowed values are Proxyonly and Always. Use Proxyonly to reference the user-ca-bundle config map only when http/https proxy is configured. Use Always to always reference the user-ca-bundle config map. The default value is Proxyonly.

[NOTE]
----
The installation program does not support the proxy readinessEndpoints field.
----

[NOTE]
----
If the installer times out, restart and then complete the deployment by using the wait-for command of the installer. For example:

```terminal
$ ./openshift-install wait-for install-complete --log-level debug
```

----
2. Save the file and reference it when installing Red Hat OpenShift Container Platform.

The installation program creates a cluster-wide proxy that is named cluster that uses the proxy
settings in the provided install-config.yaml file. If no proxy settings are
provided, a cluster Proxy object is still created, but it will have a nil
spec.


[NOTE]
----
Only the Proxy object named cluster is supported, and no additional
proxies can be created.
----

## Creating the Kubernetes manifest and Ignition config files

Because you must modify some cluster definition files and manually start the cluster machines, you must generate the Kubernetes manifest and Ignition config files that the cluster needs to configure the machines.

The installation configuration file transforms into the Kubernetes manifests. The manifests wrap into the Ignition configuration files, which are later used to configure the cluster machines.


[IMPORTANT]
----
* The Ignition config files that the Red Hat OpenShift Container Platform installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending node-bootstrapper certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for Recovering from expired control plane certificates for more information.
* It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.
----

* You obtained the Red Hat OpenShift Container Platform installation program.
For a restricted network installation, these files are on your mirror host.
* You created the install-config.yaml installation configuration file.

1. Change to the directory that contains the Red Hat OpenShift Container Platform installation program and generate the Kubernetes manifests for the cluster:

```terminal
$ ./openshift-install create manifests --dir <installation_directory> 1
```

For <installation_directory>, specify the installation directory that
contains the install-config.yaml file you created.
2. Remove the Kubernetes manifest files that define the control plane machines:

```terminal
$ rm -f <installation_directory>/openshift/99_openshift-cluster-api_master-machines-*.yaml
```


By removing these files, you prevent the cluster from automatically generating control plane machines.
3. Remove the Kubernetes manifest files that define the control plane machine set:

```terminal
$ rm -f <installation_directory>/openshift/99_openshift-machine-api_master-control-plane-machine-set.yaml
```


```terminal
$ rm -f <installation_directory>/openshift/99_openshift-cluster-api_worker-machineset-*.yaml
```


[IMPORTANT]
----
If you disabled the MachineAPI capability when installing a cluster on user-provisioned infrastructure, you must remove the Kubernetes manifest files that define the worker machines. Otherwise, your cluster fails to install.
----

Because you create and manage the worker machines yourself, you do not need to initialize these machines.
4. Check that the mastersSchedulable parameter in the <installation_directory>/manifests/cluster-scheduler-02-config.yml Kubernetes manifest file is set to false. This setting prevents pods from being scheduled on the control plane machines:
1. Open the <installation_directory>/manifests/cluster-scheduler-02-config.yml file.
2. Locate the mastersSchedulable parameter and ensure that it is set to false.
3. Save and exit the file.
5. Optional: If you do not want
the Ingress Operator
to create DNS records on your behalf, remove the privateZone and publicZone
sections from the <installation_directory>/manifests/cluster-dns-02-config.yml DNS configuration file:

```yaml
apiVersion: config.openshift.io/v1
kind: DNS
metadata:
  creationTimestamp: null
  name: cluster
spec:
  baseDomain: example.openshift.com
  privateZone: 1
    id: mycluster-100419-private-zone
  publicZone: 1
    id: example.openshift.com
status: {}
```

Remove this section completely.

If you do so, you must add ingress DNS records manually in a later step.
6. To create the Ignition configuration files, run the following command from the directory that contains the installation program:

```terminal
$ ./openshift-install create ignition-configs --dir <installation_directory> 1
```

For <installation_directory>, specify the same installation directory.

Ignition config files are created for the bootstrap, control plane, and compute nodes in the installation directory. The kubeadmin-password and kubeconfig files are created in the ./<installation_directory>/auth directory:

```
.
├── auth
│   ├── kubeadmin-password
│   └── kubeconfig
├── bootstrap.ign
├── master.ign
├── metadata.json
└── worker.ign
```


* Manually creating long-term credentials

# Extracting the infrastructure name

The Ignition config files contain a unique cluster identifier that you can use to
uniquely identify your cluster in {cp-first} ({cp}). The infrastructure name is also used to locate the appropriate {cp} resources during an Red Hat OpenShift Container Platform installation. The provided {cp-template}
templates contain references to this infrastructure name, so you must extract
it.

* You obtained the Red Hat OpenShift Container Platform installation program and the pull secret for your cluster.
* You generated the Ignition config files for your cluster.
* You installed the jq package.

* To extract and view the infrastructure name from the Ignition config file
metadata, run the following command:

```terminal
$ jq -r .infraID <installation_directory>/metadata.json 1
```

For <installation_directory>, specify the path to the directory that you stored the
installation files in.
Example output

```terminal
openshift-vw9j6 1
```

The output of this command is your cluster name and a random string.

# Creating a VPC in AWS

You must create a Virtual Private Cloud (VPC) in Amazon Web Services (AWS) for your Red Hat OpenShift Container Platform
cluster to use. You can customize the VPC to meet your requirements, including
VPN and route tables.

You can use the provided CloudFormation template and a custom parameter file to create a stack of AWS resources that represent the VPC.


[NOTE]
----
If you do not use the provided CloudFormation template to create your AWS
infrastructure, you must review the provided information and manually create
the infrastructure. If your cluster does not initialize correctly, you might
have to contact Red Hat support with your installation logs.
----

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.

1. Create a JSON file that contains the parameter values that the template
requires:

```json
[
  {
    "ParameterKey": "VpcCidr", 1
    "ParameterValue": "10.0.0.0/16" 2
  },
  {
    "ParameterKey": "AvailabilityZoneCount", 3
    "ParameterValue": "1" 4
  },
  {
    "ParameterKey": "SubnetBits", 5
    "ParameterValue": "12" 6
  }
]
```

The CIDR block for the VPC.
Specify a CIDR block in the format x.x.x.x/16-24.
The number of availability zones to deploy the VPC in.
Specify an integer between 1 and 3.
The size of each subnet in each availability zone.
Specify an integer between  5 and 13, where 5 is /27 and 13 is /19.
2. Copy the template from the CloudFormation template for the VPC
section of this topic and save it as a YAML file on your computer. This template
describes the VPC that your cluster requires.
3. Launch the CloudFormation template to create a stack of AWS resources that represent the VPC:

[IMPORTANT]
----
You must enter the command on a single line.
----

```terminal
$ aws cloudformation create-stack --stack-name <name> 1
     --template-body file://<template>.yaml 2
     --parameters file://<parameters>.json 3
```

<name> is the name for the CloudFormation stack, such as cluster-vpc.
You need the name of this stack if you remove the cluster.
<template> is the relative path to and name of the CloudFormation template
YAML file that you saved.
<parameters> is the relative path to and name of the CloudFormation
parameters JSON file.
Example output

```terminal
arn:aws:cloudformation:us-east-1:269333783861:stack/cluster-vpc/dbedae40-2fd3-11eb-820e-12a48460849f
```

4. Confirm that the template components exist:

```terminal
$ aws cloudformation describe-stacks --stack-name <name>
```


After the StackStatus displays CREATE_COMPLETE, the output displays values
for the following parameters. You must provide these parameter values to
the other CloudFormation templates that you run to create your cluster:
VpcId:: The ID of your VPC.
PublicSubnetIds:: The IDs of the new public subnets.
PrivateSubnetIds:: The IDs of the new private subnets.

## CloudFormation template for the VPC

You can use the following CloudFormation template to deploy the VPC that
you need for your Red Hat OpenShift Container Platform cluster.


```yaml
link:https://raw.githubusercontent.com/openshift/installer/release-4.15/upi/aws/cloudformation/01_vpc.yaml[role=include]
```

# Creating networking and load balancing components in AWS

You must configure networking and classic or network load balancing in Amazon Web Services (AWS) that your Red Hat OpenShift Container Platform cluster can use.

You can use the provided CloudFormation template and a custom parameter file to create a stack of AWS resources. The stack represents the networking and load balancing components that your Red Hat OpenShift Container Platform cluster requires. The template also creates a hosted zone and subnet tags.

You can run the template multiple times within a single Virtual Private Cloud (VPC).


[NOTE]
----
If you do not use the provided CloudFormation template to create your AWS
infrastructure, you must review the provided information and manually create
the infrastructure. If your cluster does not initialize correctly, you might
have to contact Red Hat support with your installation logs.
----

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.
* You created and configured a VPC and associated subnets in AWS.

1. Obtain the hosted zone ID for the Route 53 base domain that you specified in the
install-config.yaml file for your cluster. You can obtain details about your hosted zone by running the following command:

```terminal
$ aws route53 list-hosted-zones-by-name --dns-name <route53_domain> 1
```

For the <route53_domain>, specify the Route 53 base domain that you used
when you generated the install-config.yaml file for the cluster.
Example output

```terminal
mycluster.example.com.	False	100
HOSTEDZONES	65F8F38E-2268-B835-E15C-AB55336FCBFA	/hostedzone/Z21IXYZABCZ2A4	mycluster.example.com.	10
```


In the example output, the hosted zone ID is Z21IXYZABCZ2A4.
2. Create a JSON file that contains the parameter values that the template
requires:

```json
[
  {
    "ParameterKey": "ClusterName", 1
    "ParameterValue": "mycluster" 2
  },
  {
    "ParameterKey": "InfrastructureName", 3
    "ParameterValue": "mycluster-<random_string>" 4
  },
  {
    "ParameterKey": "HostedZoneId", 5
    "ParameterValue": "<random_string>" 6
  },
  {
    "ParameterKey": "HostedZoneName", 7
    "ParameterValue": "example.com" 8
  },
  {
    "ParameterKey": "PublicSubnets", 9
    "ParameterValue": "subnet-<random_string>" 10
  },
  {
    "ParameterKey": "PrivateSubnets", 11
    "ParameterValue": "subnet-<random_string>" 12
  },
  {
    "ParameterKey": "VpcId", 13
    "ParameterValue": "vpc-<random_string>" 14
  }
]
```

A short, representative cluster name to use for hostnames, etc.
Specify the cluster name that you used when you generated the
install-config.yaml file for the cluster.
The name for your cluster infrastructure that is encoded in your Ignition
config files for the cluster.
Specify the infrastructure name that you extracted from the Ignition config
file metadata, which has the format <cluster-name>-<random-string>.
The Route 53 public zone ID to register the targets with.
Specify the Route 53 public zone ID, which as a format similar to
Z21IXYZABCZ2A4. You can obtain this value from the AWS console.
The Route 53 zone to register the targets with.
Specify the Route 53 base domain that you used when you generated the
install-config.yaml file for the cluster. Do not include the trailing period
(.) that is displayed in the AWS console.
The public subnets that you created for your VPC.
Specify the PublicSubnetIds value from the output of the CloudFormation
template for the VPC.
The private subnets that you created for your VPC.
Specify the PrivateSubnetIds value from the output of the CloudFormation
template for the VPC.
The VPC that you created for the cluster.
Specify the VpcId value from the output of the CloudFormation template
for the VPC.
3. Copy the template from the CloudFormation template for the network and load balancers
section of this topic and save it as a YAML file on your computer. This template
describes the networking and load balancing objects that your cluster requires.

[IMPORTANT]
----
If you are deploying your cluster to an AWS government or secret region, you must update the InternalApiServerRecord in the CloudFormation template to use CNAME records. Records of type ALIAS are not supported for AWS government regions.
----
4. Launch the CloudFormation template to create a stack of AWS resources that provide the networking and load balancing components:

[IMPORTANT]
----
You must enter the command on a single line.
----

```terminal
$ aws cloudformation create-stack --stack-name <name> 1
     --template-body file://<template>.yaml 2
     --parameters file://<parameters>.json 3
     --capabilities CAPABILITY_NAMED_IAM 4
```

<name> is the name for the CloudFormation stack, such as cluster-dns.
You need the name of this stack if you remove the cluster.
<template> is the relative path to and name of the CloudFormation template
YAML file that you saved.
<parameters> is the relative path to and name of the CloudFormation
parameters JSON file.
You must explicitly declare the CAPABILITY_NAMED_IAM capability because the provided template creates some AWS::IAM::Role resources.
Example output

```terminal
arn:aws:cloudformation:us-east-1:269333783861:stack/cluster-dns/cd3e5de0-2fd4-11eb-5cf0-12be5c33a183
```

5. Confirm that the template components exist:

```terminal
$ aws cloudformation describe-stacks --stack-name <name>
```


After the StackStatus displays CREATE_COMPLETE, the output displays values
for the following parameters. You must provide these parameter values to
the other CloudFormation templates that you run to create your cluster:
PrivateHostedZoneId:: Hosted zone ID for the private DNS.
ExternalApiLoadBalancerName:: Full name of the external API load balancer.
InternalApiLoadBalancerName:: Full name of the internal API load balancer.
ApiServerDnsName:: Full hostname of the API server.
RegisterNlbIpTargetsLambda:: Lambda ARN useful to help register/deregister IP
targets for these load balancers.
ExternalApiTargetGroupArn:: ARN of external API target group.
InternalApiTargetGroupArn:: ARN of internal API target group.
InternalServiceTargetGroupArn:: ARN of internal service target group.

## CloudFormation template for the network and load balancers

You can use the following CloudFormation template to deploy the networking
objects and load balancers that you need for your Red Hat OpenShift Container Platform cluster.


```yaml
link:https://raw.githubusercontent.com/openshift/installer/release-4.15/upi/aws/cloudformation/02_cluster_infra.yaml[role=include]
```


[IMPORTANT]
----
If you are deploying your cluster to an AWS government or secret region, you must update the InternalApiServerRecord to use CNAME records. Records of type ALIAS are not supported for AWS government regions. For example:

```yaml
Type: CNAME
TTL: 10
ResourceRecords:
- !GetAtt IntApiElb.DNSName
```

----

* See Listing public hosted zones in the AWS documentation for more information about listing public hosted zones.

# Creating security group and roles in AWS

You must create security groups and roles in Amazon Web Services (AWS) for your Red Hat OpenShift Container Platform cluster to use.

You can use the provided CloudFormation template and a custom parameter file to create a stack of AWS resources. The stack represents the security groups and roles that your Red Hat OpenShift Container Platform cluster requires.


[NOTE]
----
If you do not use the provided CloudFormation template to create your AWS
infrastructure, you must review the provided information and manually create
the infrastructure. If your cluster does not initialize correctly, you might
have to contact Red Hat support with your installation logs.
----

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.
* You created and configured a VPC and associated subnets in AWS.

1. Create a JSON file that contains the parameter values that the template
requires:

```json
[
  {
    "ParameterKey": "InfrastructureName", 1
    "ParameterValue": "mycluster-<random_string>" 2
  },
  {
    "ParameterKey": "VpcCidr", 3
    "ParameterValue": "10.0.0.0/16" 4
  },
  {
    "ParameterKey": "PrivateSubnets", 5
    "ParameterValue": "subnet-<random_string>" 6
  },
  {
    "ParameterKey": "VpcId", 7
    "ParameterValue": "vpc-<random_string>" 8
  }
]
```

The name for your cluster infrastructure that is encoded in your Ignition
config files for the cluster.
Specify the infrastructure name that you extracted from the Ignition config
file metadata, which has the format <cluster-name>-<random-string>.
The CIDR block for the VPC.
Specify the CIDR block parameter that you used for the VPC that you defined
in the form x.x.x.x/16-24.
The private subnets that you created for your VPC.
Specify the PrivateSubnetIds value from the output of the CloudFormation
template for the VPC.
The VPC that you created for the cluster.
Specify the VpcId value from the output of the CloudFormation template for
the VPC.
2. Copy the template from the CloudFormation template for security objects
section of this topic and save it as a YAML file on your computer. This template
describes the security groups and roles that your cluster requires.
3. Launch the CloudFormation template to create a stack of AWS resources that represent the security groups and roles:

[IMPORTANT]
----
You must enter the command on a single line.
----

```terminal
$ aws cloudformation create-stack --stack-name <name> 1
     --template-body file://<template>.yaml 2
     --parameters file://<parameters>.json 3
     --capabilities CAPABILITY_NAMED_IAM 4
```

<name> is the name for the CloudFormation stack, such as cluster-sec.
You need the name of this stack if you remove the cluster.
<template> is the relative path to and name of the CloudFormation template
YAML file that you saved.
<parameters> is the relative path to and name of the CloudFormation
parameters JSON file.
You must explicitly declare the CAPABILITY_NAMED_IAM capability because the provided template creates some AWS::IAM::Role and AWS::IAM::InstanceProfile resources.
Example output

```terminal
arn:aws:cloudformation:us-east-1:269333783861:stack/cluster-sec/03bd4210-2ed7-11eb-6d7a-13fc0b61e9db
```

4. Confirm that the template components exist:

```terminal
$ aws cloudformation describe-stacks --stack-name <name>
```


After the StackStatus displays CREATE_COMPLETE, the output displays values
for the following parameters. You must provide these parameter values to
the other CloudFormation templates that you run to create your cluster:
MasterSecurityGroupId:: Master Security Group ID
WorkerSecurityGroupId:: Worker Security Group ID
MasterInstanceProfile:: Master IAM Instance Profile
WorkerInstanceProfile:: Worker IAM Instance Profile

## CloudFormation template for security objects

You can use the following CloudFormation template to deploy the security objects
that you need for your Red Hat OpenShift Container Platform cluster.


```yaml
link:https://raw.githubusercontent.com/openshift/installer/release-4.15/upi/aws/cloudformation/03_cluster_security.yaml[role=include]
```

# Accessing RHCOS AMIs with stream metadata

In Red Hat OpenShift Container Platform, stream metadata provides standardized metadata about RHCOS in the JSON format and injects the metadata into the cluster. Stream metadata is a stable format that supports multiple architectures and is intended to be self-documenting for maintaining automation.

You can use the coreos print-stream-json sub-command of openshift-install to access information about the boot images in the stream metadata format. This command provides a method for printing stream metadata in a scriptable, machine-readable format.

For user-provisioned installations, the openshift-install binary contains references to the version of RHCOS boot images that are tested for use with Red Hat OpenShift Container Platform, such as the AWS AMI.

To parse the stream metadata, use one of the following methods:

* From a Go program, use the official stream-metadata-go library at https://github.com/coreos/stream-metadata-go. You can also view example code in the library.
* From another programming language, such as Python or Ruby, use the JSON library of your preferred programming language.
* From a command-line utility that handles JSON data, such as jq:
* Print the current x86_64
or aarch64
AMI for an AWS region, such as us-west-1:
For x86_64

```terminal
$ openshift-install coreos print-stream-json | jq -r '.architectures.x86_64.images.aws.regions["us-west-1"].image'
```

Example output

```terminal
ami-0d3e625f84626bbda
```

For aarch64

```terminal
$ openshift-install coreos print-stream-json | jq -r '.architectures.aarch64.images.aws.regions["us-west-1"].image'
```

Example output

```terminal
ami-0af1d3b7fa5be2131
```


The output of this command is the AWS AMI ID for your designated architecture and the us-west-1 region. The AMI must belong to the same region as the cluster.

# RHCOS AMIs for the AWS infrastructure

Red Hat provides Red Hat Enterprise Linux CoreOS (RHCOS) AMIs that are valid for the various AWS regions and instance architectures that you can manually specify for your Red Hat OpenShift Container Platform nodes.


[NOTE]
----
By importing your own AMI, you can also install to regions that do not have a published RHCOS AMI.
----





# Creating the bootstrap node in AWS

You must create the bootstrap node in Amazon Web Services (AWS) to use during Red Hat OpenShift Container Platform cluster initialization. You do this by:

* Providing a location to serve the bootstrap.ign Ignition config file to your cluster. This file is located in your installation directory. The provided CloudFormation Template assumes that the Ignition config files for your cluster are served from an S3 bucket. If you choose to serve the files from another location, you must modify the templates.
* Using the provided CloudFormation template and a custom parameter file to create a stack of AWS resources. The stack represents the bootstrap node that your Red Hat OpenShift Container Platform installation requires.


[NOTE]
----
If you do not use the provided CloudFormation template to create your bootstrap
node, you must review the provided information and manually create
the infrastructure. If your cluster does not initialize correctly, you might
have to contact Red Hat support with your installation logs.
----

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.
* You created and configured a VPC and associated subnets in AWS.
* You created and configured DNS, load balancers, and listeners in AWS.
* You created the security groups and roles required for your cluster in AWS.

1. Create the bucket by running the following command:

```terminal
$ aws s3 mb s3://<cluster-name>-infra 1
```

<cluster-name>-infra is the bucket name. When creating the install-config.yaml file, replace <cluster-name> with the name specified for the cluster.

You must use a presigned URL for your S3 bucket, instead of the s3:// schema, if you are:
 Deploying to a region that has endpoints that differ from the AWS SDK. Deploying a proxy.
** Providing your own custom endpoints.
2. Upload the bootstrap.ign Ignition config file to the bucket by running the following command:

```terminal
$ aws s3 cp <installation_directory>/bootstrap.ign s3://<cluster-name>-infra/bootstrap.ign 1
```

For <installation_directory>, specify the path to the directory that you stored the installation files in.
3. Verify that the file uploaded by running the following command:

```terminal
$ aws s3 ls s3://<cluster-name>-infra/
```

Example output

```terminal
2019-04-03 16:15:16     314878 bootstrap.ign
```


[NOTE]
----
The bootstrap Ignition config file does contain secrets, like X.509 keys. The following steps provide basic security for the S3 bucket. To provide additional security, you can enable an S3 bucket policy to allow only certain users, such as the OpenShift IAM user, to access objects that the bucket contains. You can avoid S3 entirely and serve your bootstrap Ignition config file from any address that the bootstrap machine can reach.
----
4. Create a JSON file that contains the parameter values that the template requires:

```json
[
  {
    "ParameterKey": "InfrastructureName", 1
    "ParameterValue": "mycluster-<random_string>" 2
  },
  {
    "ParameterKey": "RhcosAmi", 3
    "ParameterValue": "ami-<random_string>" 4
  },
  {
    "ParameterKey": "AllowedBootstrapSshCidr", 5
    "ParameterValue": "0.0.0.0/0" 6
  },
  {
    "ParameterKey": "PublicSubnet", 7
    "ParameterValue": "subnet-<random_string>" 8
  },
  {
    "ParameterKey": "MasterSecurityGroupId", 9
    "ParameterValue": "sg-<random_string>" 10
  },
  {
    "ParameterKey": "VpcId", 11
    "ParameterValue": "vpc-<random_string>" 12
  },
  {
    "ParameterKey": "BootstrapIgnitionLocation", 13
    "ParameterValue": "s3://<bucket_name>/bootstrap.ign" 14
  },
  {
    "ParameterKey": "AutoRegisterELB", 15
    "ParameterValue": "yes" 16
  },
  {
    "ParameterKey": "RegisterNlbIpTargetsLambdaArn", 17
    "ParameterValue": "arn:aws:lambda:<aws_region>:<account_number>:function:<dns_stack_name>-RegisterNlbIpTargets-<random_string>" 18
  },
  {
    "ParameterKey": "ExternalApiTargetGroupArn", 19
    "ParameterValue": "arn:aws:elasticloadbalancing:<aws_region>:<account_number>:targetgroup/<dns_stack_name>-Exter-<random_string>" 20
  },
  {
    "ParameterKey": "InternalApiTargetGroupArn", 21
    "ParameterValue": "arn:aws:elasticloadbalancing:<aws_region>:<account_number>:targetgroup/<dns_stack_name>-Inter-<random_string>" 22
  },
  {
    "ParameterKey": "InternalServiceTargetGroupArn", 23
    "ParameterValue": "arn:aws:elasticloadbalancing:<aws_region>:<account_number>:targetgroup/<dns_stack_name>-Inter-<random_string>" 24
  }
]
```

The name for your cluster infrastructure that is encoded in your Ignition
config files for the cluster.
Specify the infrastructure name that you extracted from the Ignition config
file metadata, which has the format <cluster-name>-<random-string>.
Current Red Hat Enterprise Linux CoreOS (RHCOS) AMI to use for the bootstrap node based on your selected architecture.
Specify a valid AWS::EC2::Image::Id value.
CIDR block to allow SSH access to the bootstrap node.
Specify a CIDR block in the format x.x.x.x/16-24.
The public subnet that is associated with your VPC to launch the bootstrap
node into.
Specify the PublicSubnetIds value from the output of the CloudFormation
template for the VPC.
The master security group ID (for registering temporary rules)
Specify the MasterSecurityGroupId value from the output of the
CloudFormation template for the security group and roles.
The VPC created resources will belong to.
Specify the VpcId value from the output of the CloudFormation template
for the VPC.
Location to fetch bootstrap Ignition config file from.
Specify the S3 bucket and file name in the form
s3://<bucket_name>/bootstrap.ign.
Whether or not to register a network load balancer (NLB).
Specify yes or no. If you specify yes, you must provide a Lambda
Amazon Resource Name (ARN) value.
The ARN for NLB IP target registration lambda group.
Specify the RegisterNlbIpTargetsLambda value from the output of the
CloudFormation template for DNS and load balancing. Use arn:aws-us-gov if
deploying the cluster to an AWS GovCloud region.
The ARN for external API load balancer target group.
Specify the ExternalApiTargetGroupArn value from the output of the
CloudFormation template for DNS and load balancing. Use arn:aws-us-gov if
deploying the cluster to an AWS GovCloud region.
The ARN for internal API load balancer target group.
Specify the InternalApiTargetGroupArn value from the output of the
CloudFormation template for DNS and load balancing. Use arn:aws-us-gov if
deploying the cluster to an AWS GovCloud region.
The ARN for internal service load balancer target group.
Specify the InternalServiceTargetGroupArn value from the output of the
CloudFormation template for DNS and load balancing. Use arn:aws-us-gov if
deploying the cluster to an AWS GovCloud region.
5. Copy the template from the CloudFormation template for the bootstrap machine
section of this topic and save it as a YAML file on your computer. This template
describes the bootstrap machine that your cluster requires.
6. Optional: If you are deploying the cluster with a proxy, you must update the ignition in the template to add the  ignition.config.proxy fields. Additionally, If you have added the Amazon EC2, Elastic Load Balancing, and S3 VPC endpoints to your VPC, you must add these endpoints to the noProxy field.
7. Launch the CloudFormation template to create a stack of AWS resources that represent the bootstrap node:

[IMPORTANT]
----
You must enter the command on a single line.
----

```terminal
$ aws cloudformation create-stack --stack-name <name> 1
     --template-body file://<template>.yaml 2
     --parameters file://<parameters>.json 3
     --capabilities CAPABILITY_NAMED_IAM 4
```

<name> is the name for the CloudFormation stack, such as cluster-bootstrap.
You need the name of this stack if you remove the cluster.
<template> is the relative path to and name of the CloudFormation template
YAML file that you saved.
<parameters> is the relative path to and name of the CloudFormation
parameters JSON file.
You must explicitly declare the CAPABILITY_NAMED_IAM capability because the provided template creates some AWS::IAM::Role and AWS::IAM::InstanceProfile resources.
Example output

```terminal
arn:aws:cloudformation:us-east-1:269333783861:stack/cluster-bootstrap/12944486-2add-11eb-9dee-12dace8e3a83
```

8. Confirm that the template components exist:

```terminal
$ aws cloudformation describe-stacks --stack-name <name>
```


After the StackStatus displays CREATE_COMPLETE, the output displays values
for the following parameters. You must provide these parameter values to
the other CloudFormation templates that you run to create your cluster:
BootstrapInstanceId:: The bootstrap Instance ID.
BootstrapPublicIp:: The bootstrap node public IP address.
BootstrapPrivateIp:: The bootstrap node private IP address.

## CloudFormation template for the bootstrap machine

You can use the following CloudFormation template to deploy the bootstrap machine that you need for your Red Hat OpenShift Container Platform cluster.


```yaml
link:https://raw.githubusercontent.com/openshift/installer/release-4.15/upi/aws/cloudformation/04_cluster_bootstrap.yaml[role=include]
```

* See RHCOS AMIs for the AWS infrastructure for details about the Red Hat Enterprise Linux CoreOS (RHCOS) AMIs for the AWS zones.

# Creating the control plane machines in AWS

You must create the control plane machines in Amazon Web Services (AWS) that your cluster will use.

You can use the provided CloudFormation template and a custom parameter file to create a stack of AWS resources that represent the control plane nodes.


[IMPORTANT]
----
The CloudFormation template creates a stack that represents three control plane nodes.
----


[NOTE]
----
If you do not use the provided CloudFormation template to create your control plane
nodes, you must review the provided information and manually create
the infrastructure. If your cluster does not initialize correctly, you might
have to contact Red Hat support with your installation logs.
----

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.
* You created and configured a VPC and associated subnets in AWS.
* You created and configured DNS, load balancers, and listeners in AWS.
* You created the security groups and roles required for your cluster in AWS.
* You created the bootstrap machine.

1. Create a JSON file that contains the parameter values that the template
requires:

```json
[
  {
    "ParameterKey": "InfrastructureName", 1
    "ParameterValue": "mycluster-<random_string>" 2
  },
  {
    "ParameterKey": "RhcosAmi", 3
    "ParameterValue": "ami-<random_string>" 4
  },
  {
    "ParameterKey": "AutoRegisterDNS", 5
    "ParameterValue": "yes" 6
  },
  {
    "ParameterKey": "PrivateHostedZoneId", 7
    "ParameterValue": "<random_string>" 8
  },
  {
    "ParameterKey": "PrivateHostedZoneName", 9
    "ParameterValue": "mycluster.example.com" 10
  },
  {
    "ParameterKey": "Master0Subnet", 11
    "ParameterValue": "subnet-<random_string>" 12
  },
  {
    "ParameterKey": "Master1Subnet", 11
    "ParameterValue": "subnet-<random_string>" 12
  },
  {
    "ParameterKey": "Master2Subnet", 11
    "ParameterValue": "subnet-<random_string>" 12
  },
  {
    "ParameterKey": "MasterSecurityGroupId", 13
    "ParameterValue": "sg-<random_string>" 14
  },
  {
    "ParameterKey": "IgnitionLocation", 15
    "ParameterValue": "https://api-int.<cluster_name>.<domain_name>:22623/config/master" 16
  },
  {
    "ParameterKey": "CertificateAuthorities", 17
    "ParameterValue": "data:text/plain;charset=utf-8;base64,ABC...xYz==" 18
  },
  {
    "ParameterKey": "MasterInstanceProfileName", 19
    "ParameterValue": "<roles_stack>-MasterInstanceProfile-<random_string>" 20
  },
  {
    "ParameterKey": "MasterInstanceType", 21
    "ParameterValue": "" 22
  },
  {
    "ParameterKey": "AutoRegisterELB", 23
    "ParameterValue": "yes" 24
  },
  {
    "ParameterKey": "RegisterNlbIpTargetsLambdaArn", 25
    "ParameterValue": "arn:aws:lambda:<aws_region>:<account_number>:function:<dns_stack_name>-RegisterNlbIpTargets-<random_string>" 26
  },
  {
    "ParameterKey": "ExternalApiTargetGroupArn", 27
    "ParameterValue": "arn:aws:elasticloadbalancing:<aws_region>:<account_number>:targetgroup/<dns_stack_name>-Exter-<random_string>" 28
  },
  {
    "ParameterKey": "InternalApiTargetGroupArn", 29
    "ParameterValue": "arn:aws:elasticloadbalancing:<aws_region>:<account_number>:targetgroup/<dns_stack_name>-Inter-<random_string>" 30
  },
  {
    "ParameterKey": "InternalServiceTargetGroupArn", 31
    "ParameterValue": "arn:aws:elasticloadbalancing:<aws_region>:<account_number>:targetgroup/<dns_stack_name>-Inter-<random_string>" 32
  }
]
```

The name for your cluster infrastructure that is encoded in your Ignition
config files for the cluster.
Specify the infrastructure name that you extracted from the Ignition config
file metadata, which has the format <cluster-name>-<random-string>.
Current Red Hat Enterprise Linux CoreOS (RHCOS) AMI to use for the control plane machines based on your selected architecture.
Specify an AWS::EC2::Image::Id value.
Whether or not to perform DNS etcd registration.
Specify yes or no. If you specify yes, you must provide hosted zone
information.
The Route 53 private zone ID to register the etcd targets with.
Specify the PrivateHostedZoneId value from the output of the
CloudFormation template for DNS and load balancing.
The Route 53 zone to register the targets with.
Specify <cluster_name>.<domain_name> where <domain_name> is the Route 53
base domain that you used when you generated install-config.yaml file for the
cluster. Do not include the trailing period (.) that is
displayed in the AWS console.
A subnet, preferably private, to launch the control plane machines on.
Specify a subnet from the PrivateSubnets value from the output of the
CloudFormation template for DNS and load balancing.
The master security group ID to associate with control plane nodes.
Specify the MasterSecurityGroupId value from the output of the
CloudFormation template for the security group and roles.
The location to fetch control plane Ignition config file from.
Specify the generated Ignition config file location,
https://api-int.<cluster_name>.<domain_name>:22623/config/master.
The base64 encoded certificate authority string to use.
Specify the value from the master.ign file that is in the installation
directory. This value is the long string with the format
data:text/plain;charset=utf-8;base64,ABC&#8230;&#8203;xYz==.
The IAM profile to associate with control plane nodes.
Specify the MasterInstanceProfile parameter value from the output of
the CloudFormation template for the security group and roles.
The type of AWS instance to use for the control plane machines based on your selected architecture.
The instance type value corresponds to the minimum resource requirements for
control plane machines. For example m6i.xlarge is a type for AMD64
and m6g.xlarge is a type for ARM64.
Whether or not to register a network load balancer (NLB).
Specify yes or no. If you specify yes, you must provide a Lambda
Amazon Resource Name (ARN) value.
The ARN for NLB IP target registration lambda group.
Specify the RegisterNlbIpTargetsLambda value from the output of the CloudFormation template for DNS
and load balancing. Use arn:aws-us-gov if deploying the cluster to an AWS
GovCloud region.
The ARN for external API load balancer target group.
Specify the ExternalApiTargetGroupArn value from the output of the CloudFormation template for DNS
and load balancing. Use arn:aws-us-gov if deploying the cluster to an AWS
GovCloud region.
The ARN for internal API load balancer target group.
Specify the InternalApiTargetGroupArn value from the output of the CloudFormation template for DNS
and load balancing. Use arn:aws-us-gov if deploying the cluster to an AWS
GovCloud region.
The ARN for internal service load balancer target group.
Specify the InternalServiceTargetGroupArn value from the output of the CloudFormation template for DNS
and load balancing. Use arn:aws-us-gov if deploying the cluster to an AWS
GovCloud region.
2. Copy the template from the CloudFormation template for control plane machines
section of this topic and save it as a YAML file on your computer. This template
describes the control plane machines that your cluster requires.
3. If you specified an m5 instance type as the value for MasterInstanceType,
add that instance type to the MasterInstanceType.AllowedValues parameter
in the CloudFormation template.
4. Launch the CloudFormation template to create a stack of AWS resources that represent the control plane nodes:

[IMPORTANT]
----
You must enter the command on a single line.
----

```terminal
$ aws cloudformation create-stack --stack-name <name> 1
     --template-body file://<template>.yaml 2
     --parameters file://<parameters>.json 3
```

<name> is the name for the CloudFormation stack, such as cluster-control-plane.
You need the name of this stack if you remove the cluster.
<template> is the relative path to and name of the CloudFormation template
YAML file that you saved.
<parameters> is the relative path to and name of the CloudFormation
parameters JSON file.
Example output

```terminal
arn:aws:cloudformation:us-east-1:269333783861:stack/cluster-control-plane/21c7e2b0-2ee2-11eb-c6f6-0aa34627df4b
```


[NOTE]
----
The CloudFormation template creates a stack that represents three control plane nodes.
----
5. Confirm that the template components exist:

```terminal
$ aws cloudformation describe-stacks --stack-name <name>
```


## CloudFormation template for control plane machines

You can use the following CloudFormation template to deploy the control plane
machines that you need for your Red Hat OpenShift Container Platform cluster.


```yaml
link:https://raw.githubusercontent.com/openshift/installer/release-4.15/upi/aws/cloudformation/05_cluster_master_nodes.yaml[role=include]
```

# Creating the worker nodes in AWS

You can create worker nodes in Amazon Web Services (AWS) for your cluster to use.

You can use the provided CloudFormation template and a custom parameter file to create a stack of AWS resources that represent a worker node.


[IMPORTANT]
----
The CloudFormation template creates a stack that represents one worker node.
You must create a stack for each worker node.
----


[NOTE]
----
If you do not use the provided CloudFormation template to create your worker
nodes, you must review the provided information and manually create
the infrastructure. If your cluster does not initialize correctly, you might
have to contact Red Hat support with your installation logs.
----

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.
* You created and configured a VPC and associated subnets in AWS.
* You created and configured DNS, load balancers, and listeners in AWS.
* You created the security groups and roles required for your cluster in AWS.
* You created the bootstrap machine.
* You created the control plane machines.

1. Create a JSON file that contains the parameter values that the CloudFormation
template requires:

```json
[
  {
    "ParameterKey": "InfrastructureName", 1
    "ParameterValue": "mycluster-<random_string>" 2
  },
  {
    "ParameterKey": "RhcosAmi", 3
    "ParameterValue": "ami-<random_string>" 4
  },
  {
    "ParameterKey": "Subnet", 5
    "ParameterValue": "subnet-<random_string>" 6
  },
  {
    "ParameterKey": "WorkerSecurityGroupId", 7
    "ParameterValue": "sg-<random_string>" 8
  },
  {
    "ParameterKey": "IgnitionLocation", 9
    "ParameterValue": "https://api-int.<cluster_name>.<domain_name>:22623/config/worker" 10
  },
  {
    "ParameterKey": "CertificateAuthorities", 11
    "ParameterValue": "" 12
  },
  {
    "ParameterKey": "WorkerInstanceProfileName", 13
    "ParameterValue": "" 14
  },
  {
    "ParameterKey": "WorkerInstanceType", 15
    "ParameterValue": "" 16
  }
]
```

The name for your cluster infrastructure that is encoded in your Ignition
config files for the cluster.
Specify the infrastructure name that you extracted from the Ignition config
file metadata, which has the format <cluster-name>-<random-string>.
Current Red Hat Enterprise Linux CoreOS (RHCOS) AMI to use for the worker nodes based on your selected architecture.
Specify an AWS::EC2::Image::Id value.
A subnet, preferably private, to start the worker nodes on.
Specify a subnet from the PrivateSubnets value from the output of the
CloudFormation template for DNS and load balancing.
The worker security group ID to associate with worker nodes.
Specify the WorkerSecurityGroupId value from the output of the
CloudFormation template for the security group and roles.
The location to fetch the bootstrap Ignition config file from.
Specify the generated Ignition config location,
https://api-int.<cluster_name>.<domain_name>:22623/config/worker.
Base64 encoded certificate authority string to use.
Specify the value from the worker.ign file that is in the installation
directory. This value is the long string with the format
data:text/plain;charset=utf-8;base64,ABC&#8230;&#8203;xYz==.
The IAM profile to associate with worker nodes.
Specify the WorkerInstanceProfile parameter value from the output of
the CloudFormation template for the security group and roles.
The type of AWS instance to use for the compute machines based on your selected architecture.
The instance type value corresponds to the minimum resource requirements
for compute machines. For example m6i.large is a type for AMD64
 and m6g.large is a type for ARM64.
2. Copy the template from the CloudFormation template for worker machines
section of this topic and save it as a YAML file on your computer. This template
describes the networking objects and load balancers that your cluster requires.
3. Optional: If you specified an m5 instance type as the value for WorkerInstanceType, add that instance type to the WorkerInstanceType.AllowedValues parameter in the CloudFormation template.
4. Optional: If you are deploying with an AWS Marketplace image, update the Worker0.type.properties.ImageID parameter with the AMI ID that you obtained from your subscription.
5. Use the CloudFormation template to create a stack of AWS resources that represent a worker node:

[IMPORTANT]
----
You must enter the command on a single line.
----

```terminal
$ aws cloudformation create-stack --stack-name <name> 1
     --template-body file://<template>.yaml \ 2
     --parameters file://<parameters>.json 3
```

<name> is the name for the CloudFormation stack, such as cluster-worker-1.
You need the name of this stack if you remove the cluster.
<template> is the relative path to and name of the CloudFormation template
YAML file that you saved.
<parameters> is the relative path to and name of the CloudFormation
parameters JSON file.
Example output

```terminal
arn:aws:cloudformation:us-east-1:269333783861:stack/cluster-worker-1/729ee301-1c2a-11eb-348f-sd9888c65b59
```


[NOTE]
----
The CloudFormation template creates a stack that represents one worker node.
----
6. Confirm that the template components exist:

```terminal
$ aws cloudformation describe-stacks --stack-name <name>
```

7. Continue to create worker stacks until you have created enough worker machines for your cluster. You can create additional worker stacks by referencing the same template and parameter files and specifying a different stack name.

[IMPORTANT]
----
You must create at least two worker machines, so you must create at least
two stacks that use this CloudFormation template.
----

## CloudFormation template for worker machines

You can use the following CloudFormation template to deploy the worker machines
that you need for your Red Hat OpenShift Container Platform cluster.


```yaml
link:https://raw.githubusercontent.com/openshift/installer/release-4.15/upi/aws/cloudformation/06_cluster_worker_node.yaml[role=include]
```

# Initializing the bootstrap sequence on AWS with user-provisioned infrastructure

After you create all of the required infrastructure in Amazon Web Services (AWS),
you can start the bootstrap sequence that initializes the Red Hat OpenShift Container Platform control plane.

* You configured an AWS account.
* You added your AWS keys and region to your local AWS profile by running aws configure.
* You generated the Ignition config files for your cluster.
* You created and configured a VPC and associated subnets in AWS.
* You created and configured DNS, load balancers, and listeners in AWS.
* You created the security groups and roles required for your cluster in AWS.
* You created the bootstrap machine.
* You created the control plane machines.
* You created the worker nodes.

1. Change to the directory that contains the installation program and start the bootstrap process that initializes the Red Hat OpenShift Container Platform control plane:

```terminal
$ ./openshift-install wait-for bootstrap-complete --dir <installation_directory> \ 1
    --log-level=info 2
```

For <installation_directory>, specify the path to the directory that you
stored the installation files in.
To view different installation details, specify warn, debug, or
error instead of info.
Example output

```terminal
INFO Waiting up to 20m0s for the Kubernetes API at https://api.mycluster.example.com:6443...
INFO API v1.28.5 up
INFO Waiting up to 30m0s for bootstrapping to complete...
INFO It is now safe to remove the bootstrap resources
INFO Time elapsed: 1s
```


If the command exits without a FATAL warning, your Red Hat OpenShift Container Platform control plane
has initialized.

[NOTE]
----
After the control plane initializes, it sets up the compute nodes and installs additional services in the form of Operators.
----

* See Monitoring installation progress for details about monitoring the installation, bootstrap, and control plane logs as an Red Hat OpenShift Container Platform installation progresses.
* See Gathering bootstrap node diagnostic data for information about troubleshooting issues related to the bootstrap process.

# Logging in to the cluster by using the CLI

You can log in to your cluster as a default system user by exporting the cluster kubeconfig file.
The kubeconfig file contains information about the cluster that is used by the CLI to connect a client to the correct cluster and API server.
The file is specific to a cluster and is created during Red Hat OpenShift Container Platform installation.

* You deployed an Red Hat OpenShift Container Platform cluster.
* You installed the oc CLI.

1. Export the kubeadmin credentials:

```terminal
$ export KUBECONFIG=<installation_directory>/auth/kubeconfig 1
```

For <installation_directory>, specify the path to the directory that you stored
the installation files in.
2. Verify you can run oc commands successfully using the exported configuration:

```terminal
$ oc whoami
```

Example output

```terminal
system:admin
```


# Approving the certificate signing requests for your machines

When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.

* You added machines to your cluster.

1. Confirm that the cluster recognizes the machines:

```terminal
$ oc get nodes
```

Example output

```terminal
NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5
```


The output lists all of the machines that you created.

[NOTE]
----
The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.
----
2. Review the pending CSRs and ensure that you see the client requests with the Pending or Approved status for each machine that you added to the cluster:

```terminal
$ oc get csr
```

Example output

```terminal
NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...
```


In this example, two machines are joining the cluster. You might see more approved CSRs in the list.
3. If the CSRs were not approved, after all of the pending CSRs for the machines you added are in Pending status, approve the CSRs for your cluster machines:

[NOTE]
----
Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the machine-approver if the Kubelet requests a new certificate with identical parameters.
----

[NOTE]
----
For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the oc exec, oc rsh, and oc logs commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the node-bootstrapper service account in the system:node or system:admin groups, and confirm the identity of the node.
----
* To approve them individually, run the following command for each valid CSR:

```terminal
$ oc adm certificate approve <csr_name> 1
```

<csr_name> is the name of a CSR from the list of current CSRs.
* To approve all pending CSRs, run the following command:

```terminal
$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve
```


[NOTE]
----
Some Operators might not become available until some CSRs are approved.
----
4. Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:

```terminal
$ oc get csr
```

Example output

```terminal
NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...
```

5. If the remaining CSRs are not approved, and are in the Pending status, approve the CSRs for your cluster machines:
* To approve them individually, run the following command for each valid CSR:

```terminal
$ oc adm certificate approve <csr_name> 1
```

<csr_name> is the name of a CSR from the list of current CSRs.
* To approve all pending CSRs, run the following command:

```terminal
$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve
```

6. After all client and server CSRs have been approved, the machines have the Ready status. Verify this by running the following command:

```terminal
$ oc get nodes
```

Example output

```terminal
NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5
```


[NOTE]
----
It can take a few minutes after approval of the server CSRs for the machines to transition to the Ready status.
----

* For more information on CSRs, see Certificate Signing Requests.

# Initial Operator configuration

After the control plane initializes, you must immediately configure some
Operators so that they all become available.

* Your control plane has initialized.

1. Watch the cluster components come online:

```terminal
$ watch -n5 oc get clusteroperators
```

Example output

```terminal
NAME                                       VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE
authentication                             4.15.0    True        False         False      19m
baremetal                                  4.15.0    True        False         False      37m
cloud-credential                           4.15.0    True        False         False      40m
cluster-autoscaler                         4.15.0    True        False         False      37m
config-operator                            4.15.0    True        False         False      38m
console                                    4.15.0    True        False         False      26m
csi-snapshot-controller                    4.15.0    True        False         False      37m
dns                                        4.15.0    True        False         False      37m
etcd                                       4.15.0    True        False         False      36m
image-registry                             4.15.0    True        False         False      31m
ingress                                    4.15.0    True        False         False      30m
insights                                   4.15.0    True        False         False      31m
kube-apiserver                             4.15.0    True        False         False      26m
kube-controller-manager                    4.15.0    True        False         False      36m
kube-scheduler                             4.15.0    True        False         False      36m
kube-storage-version-migrator              4.15.0    True        False         False      37m
machine-api                                4.15.0    True        False         False      29m
machine-approver                           4.15.0    True        False         False      37m
machine-config                             4.15.0    True        False         False      36m
marketplace                                4.15.0    True        False         False      37m
monitoring                                 4.15.0    True        False         False      29m
network                                    4.15.0    True        False         False      38m
node-tuning                                4.15.0    True        False         False      37m
openshift-apiserver                        4.15.0    True        False         False      32m
openshift-controller-manager               4.15.0    True        False         False      30m
openshift-samples                          4.15.0    True        False         False      32m
operator-lifecycle-manager                 4.15.0    True        False         False      37m
operator-lifecycle-manager-catalog         4.15.0    True        False         False      37m
operator-lifecycle-manager-packageserver   4.15.0    True        False         False      32m
service-ca                                 4.15.0    True        False         False      38m
storage                                    4.15.0    True        False         False      37m
```

2. Configure the Operators that are not available.

## Disabling the default OperatorHub catalog sources

Operator catalogs that source content provided by Red Hat and community projects are configured for OperatorHub by default during an Red Hat OpenShift Container Platform installation.
In a restricted network environment, you must disable the default catalogs as a cluster administrator.

* Disable the sources for the default catalogs by adding disableAllDefaultSources: true to the OperatorHub object:

```terminal
$ oc patch OperatorHub cluster --type json \
    -p '[{"op": "add", "path": "/spec/disableAllDefaultSources", "value": true}]'
```



[TIP]
----
Alternatively, you can use the web console to manage catalog sources. From the Administration -> Cluster Settings -> Configuration -> OperatorHub page, click the Sources tab, where you can create, update, delete, disable, and enable individual sources.
----

## Image registry storage configuration

Amazon Web Services provides default storage, which means the Image Registry
Operator is available after installation. However, if the Registry Operator
cannot create an S3 bucket and automatically configure storage, you must
manually configure registry storage.

Instructions are shown for configuring a persistent volume, which is required for production clusters. Where applicable, instructions are shown for configuring an empty directory as the storage location, which is available for only non-production clusters.

Additional instructions are provided for allowing the image registry to use block storage types by using the Recreate rollout strategy during upgrades.

### Configuring registry storage for AWS with user-provisioned infrastructure

During installation, your cloud credentials are sufficient to create an Amazon S3 bucket
and the Registry Operator will automatically configure storage.

If the Registry Operator cannot create an S3 bucket and automatically configure
storage, you can create an S3 bucket and configure storage with the following
procedure.

* You have a cluster on AWS with user-provisioned infrastructure.
* For Amazon S3 storage, the secret is expected to contain two keys:
* REGISTRY_STORAGE_S3_ACCESSKEY
* REGISTRY_STORAGE_S3_SECRETKEY

Use the following procedure if the Registry Operator cannot create an S3 bucket
and automatically configure storage.

1. Set up a Bucket Lifecycle Policy
to abort incomplete multipart uploads that are one day old.
2. Fill in the storage configuration in
configs.imageregistry.operator.openshift.io/cluster:

```terminal
$ oc edit configs.imageregistry.operator.openshift.io/cluster
```

Example configuration

```yaml
storage:
  s3:
    bucket: <bucket-name>
    region: <region-name>
```



[WARNING]
----
To secure your registry images in AWS, block public access
to the S3 bucket.
----

### Configuring storage for the image registry in non-production clusters

You must configure storage for the Image Registry Operator. For non-production
clusters, you can set the image registry to an empty directory. If you do so,
all images are lost if you restart the registry.

* To set the image registry storage to an empty directory:

```terminal
$ oc patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"storage":{"emptyDir":{}}}}'
```


[WARNING]
----
Configure this option for only non-production clusters.
----

If you run this command before the Image Registry Operator initializes its
components, the oc patch command fails with the following error:

```terminal
Error from server (NotFound): configs.imageregistry.operator.openshift.io "cluster" not found
```


Wait a few minutes and run the command again.

# Deleting the bootstrap resources

After you complete the initial Operator configuration for the cluster, remove the bootstrap resources from Amazon Web Services (AWS).

* You completed the initial Operator configuration for your cluster.

1. Delete the bootstrap resources. If you used the CloudFormation template,
delete its stack:
* Delete the stack by using the AWS CLI:

```terminal
$ aws cloudformation delete-stack --stack-name <name> 1
```

<name> is the name of your bootstrap stack.
* Delete the stack by using the AWS CloudFormation console.

# Creating the Ingress DNS Records

If you removed the DNS Zone configuration, manually create DNS records that point to the Ingress load balancer.
You can create either a wildcard record or specific records. While the following procedure uses A records, you can use other record types that you require, such as CNAME or alias.

* You deployed an Red Hat OpenShift Container Platform cluster on Amazon Web Services (AWS) that uses infrastructure that you provisioned.
* You installed the OpenShift CLI (oc).
* You installed the jq package.
* You downloaded the AWS CLI and installed it on your computer. See
Install the AWS CLI Using the Bundled Installer (Linux, macOS, or Unix).

1. Determine the routes to create.
* To create a wildcard record, use *.apps.<cluster_name>.<domain_name>, where <cluster_name> is your cluster name, and <domain_name> is the Route 53 base domain for your Red Hat OpenShift Container Platform cluster.
* To create specific records, you must create a record for each route that your cluster uses, as shown in the output of the following command:

```terminal
$ oc get --all-namespaces -o jsonpath='{range .items[*]}{range .status.ingress[*]}{.host}{"\n"}{end}{end}' routes
```

Example output

```terminal
oauth-openshift.apps.<cluster_name>.<domain_name>
console-openshift-console.apps.<cluster_name>.<domain_name>
downloads-openshift-console.apps.<cluster_name>.<domain_name>
alertmanager-main-openshift-monitoring.apps.<cluster_name>.<domain_name>
prometheus-k8s-openshift-monitoring.apps.<cluster_name>.<domain_name>
```

2. Retrieve the Ingress Operator load balancer status and note the value of the external IP address that it uses, which is shown in the EXTERNAL-IP column:

```terminal
$ oc -n openshift-ingress get service router-default
```

Example output

```terminal
NAME             TYPE           CLUSTER-IP      EXTERNAL-IP                            PORT(S)                      AGE
router-default   LoadBalancer   172.30.62.215   ab3...28.us-east-2.elb.amazonaws.com   80:31499/TCP,443:30693/TCP   5m
```

3. Locate the hosted zone ID for the load balancer:

```terminal
$ aws elb describe-load-balancers | jq -r '.LoadBalancerDescriptions[] | select(.DNSName == "<external_ip>").CanonicalHostedZoneNameID' 1
```

For <external_ip>, specify the value of the external IP address of the Ingress Operator load balancer that you obtained.
Example output

```terminal
Z3AADJGX6KTTL2
```


The output of this command is the load balancer hosted zone ID.
4. Obtain the public hosted zone ID for your cluster's domain:

```terminal
$ aws route53 list-hosted-zones-by-name \
            --dns-name "<domain_name>" \ 1
            --query 'HostedZones[? Config.PrivateZone != `true` && Name == `<domain_name>.`].Id' 1
            --output text
```

For <domain_name>, specify the Route 53 base domain for your Red Hat OpenShift Container Platform cluster.
Example output

```terminal
/hostedzone/Z3URY6TWQ91KVV
```


The public hosted zone ID for your domain is shown in the command output. In this example, it is Z3URY6TWQ91KVV.
5. Add the alias records to your private zone:

```terminal
$ aws route53 change-resource-record-sets --hosted-zone-id "<private_hosted_zone_id>" --change-batch '{ 1
>   "Changes": [
>     {
>       "Action": "CREATE",
>       "ResourceRecordSet": {
>         "Name": "\\052.apps.<cluster_domain>", 2
>         "Type": "A",
>         "AliasTarget":{
>           "HostedZoneId": "<hosted_zone_id>", 3
>           "DNSName": "<external_ip>.", 4
>           "EvaluateTargetHealth": false
>         }
>       }
>     }
>   ]
> }'
```

For <private_hosted_zone_id>, specify the value from the output of the CloudFormation template for DNS and load balancing.
For <cluster_domain>, specify the domain or subdomain that you use with your Red Hat OpenShift Container Platform cluster.
For <hosted_zone_id>, specify the public hosted zone ID for the load balancer that you obtained.
For <external_ip>, specify the value of the external IP address of the Ingress Operator load balancer. Ensure that you include the trailing period (.) in this parameter value.
6. Add the records to your public zone:

```terminal
$ aws route53 change-resource-record-sets --hosted-zone-id "<public_hosted_zone_id>"" --change-batch '{ 1
>   "Changes": [
>     {
>       "Action": "CREATE",
>       "ResourceRecordSet": {
>         "Name": "\\052.apps.<cluster_domain>", 2
>         "Type": "A",
>         "AliasTarget":{
>           "HostedZoneId": "<hosted_zone_id>", 3
>           "DNSName": "<external_ip>.", 4
>           "EvaluateTargetHealth": false
>         }
>       }
>     }
>   ]
> }'
```

For <public_hosted_zone_id>, specify the public hosted zone for your domain.
For <cluster_domain>, specify the domain or subdomain that you use with your Red Hat OpenShift Container Platform cluster.
For <hosted_zone_id>, specify the public hosted zone ID for the load balancer that you obtained.
For <external_ip>, specify the value of the external IP address of the Ingress Operator load balancer. Ensure that you include the trailing period (.) in this parameter value.

# Completing an AWS installation on user-provisioned infrastructure

After you start the Red Hat OpenShift Container Platform installation on Amazon Web Service (AWS)
user-provisioned infrastructure, monitor the deployment to completion.

* You removed the bootstrap node for an Red Hat OpenShift Container Platform cluster on user-provisioned AWS infrastructure.
* You installed the oc CLI.

1. From the directory that contains the installation program, complete
the cluster installation:

```terminal
$ ./openshift-install --dir <installation_directory> wait-for install-complete 1
```

For <installation_directory>, specify the path to the directory that you
stored the installation files in.
Example output

```terminal
INFO Waiting up to 40m0s for the cluster at https://api.mycluster.example.com:6443 to initialize...
INFO Waiting up to 10m0s for the openshift-console route to be created...
INFO Install complete!
INFO To access the cluster as the system:admin user when using 'oc', run 'export KUBECONFIG=/home/myuser/install_dir/auth/kubeconfig'
INFO Access the OpenShift web-console here: https://console-openshift-console.apps.mycluster.example.com
INFO Login to the console with user: "kubeadmin", and password: "password"
INFO Time elapsed: 1s
```


[IMPORTANT]
----
* The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending node-bootstrapper certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for Recovering from expired control plane certificates for more information.
* It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.
----
2. Register your cluster on the Cluster registration page.

# Logging in to the cluster by using the web console

The kubeadmin user exists by default after an Red Hat OpenShift Container Platform installation. You can log in to your cluster as the kubeadmin user by using the Red Hat OpenShift Container Platform web console.

* You have access to the installation host.
* You completed a cluster installation and all cluster Operators are available.

1. Obtain the password for the kubeadmin user from the kubeadmin-password file on the installation host:

```terminal
$ cat <installation_directory>/auth/kubeadmin-password
```


[NOTE]
----
Alternatively, you can obtain the kubeadmin password from the <installation_directory>/.openshift_install.log log file on the installation host.
----
2. List the Red Hat OpenShift Container Platform web console route:

```terminal
$ oc get routes -n openshift-console | grep 'console-openshift'
```


[NOTE]
----
Alternatively, you can obtain the Red Hat OpenShift Container Platform route from the <installation_directory>/.openshift_install.log log file on the installation host.
----
Example output

```terminal
console     console-openshift-console.apps.<cluster_name>.<base_domain>            console     https   reencrypt/Redirect   None
```

3. Navigate to the route detailed in the output of the preceding command in a web browser and log in as the kubeadmin user.

* See Accessing the web console for more details about accessing and understanding the Red Hat OpenShift Container Platform web console.

# Telemetry access for Red Hat OpenShift Container Platform

In Red Hat OpenShift Container Platform 4.15, the Telemetry service, which runs by default to provide metrics about cluster health and the success of updates, requires internet access. If your cluster is connected to the internet, Telemetry runs automatically, and your cluster is registered to https://console.redhat.com/openshift [OpenShift Cluster Manager].

After you confirm that your https://console.redhat.com/openshift [OpenShift Cluster Manager] inventory is correct, either maintained automatically by Telemetry or manually by using OpenShift Cluster Manager, use subscription watch to track your Red Hat OpenShift Container Platform subscriptions at the account or multi-cluster level.

* See About remote health monitoring for more information about the Telemetry service

# Additional resources

* See Working with stacks in the AWS documentation for more information about AWS CloudFormation stacks.

# Next steps

* Validate an installation.
* Customize your cluster.
* Configure image streams for the Cluster Samples Operator and the must-gather tool.
* Learn how to use Operator Lifecycle Manager (OLM) on restricted networks.
* If the mirror registry that you used to install your cluster has a trusted CA, add it to the cluster by configuring additional trust stores.
* If necessary, you can opt out of remote health reporting.
* If necessary, see Registering your disconnected cluster
* If necessary, you can remove cloud provider credentials.