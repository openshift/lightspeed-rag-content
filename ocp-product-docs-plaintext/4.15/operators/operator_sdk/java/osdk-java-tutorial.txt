Operator SDK tutorial for Java-based Operators
Java-based Operator SDK is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.

For more information about the support scope of Red Hat Technology Preview features, see Technology Preview Features Support Scope.

Operator developers can take advantage of Java programming language support in the Operator SDK to build an example Java-based Operator for Memcached, a distributed key-value store, and manage its lifecycle.

This process is accomplished using two centerpieces of the Operator Framework:


Operator SDK
The operator-sdk CLI tool and java-operator-sdk library API
Operator Lifecycle Manager (OLM)
Installation, upgrade, and role-based access control (RBAC) of Operators on a cluster


This tutorial goes into greater detail than Getting started with Operator SDK for Java-based Operators.
Prerequisites
Operator SDK CLI installed

OpenShift CLI (oc) 4.15+ installed

Java 11+

Maven 3.6.3+

Logged into an Red Hat OpenShift Container Platform 4.15 cluster with oc with an account that has cluster-admin permissions

To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret


Installing the Operator SDK CLI

Getting started with the OpenShift CLI
Creating a project
Use the Operator SDK CLI to create a project called memcached-operator.

Create a directory for the project:

Change to the directory:

Run the operator-sdk init command
with the quarkus plugin
to initialize the project:


PROJECT file
Among the files generated by the operator-sdk init command is a Kubebuilder PROJECT file. Subsequent operator-sdk commands, as well as help output, that are run from the project root read this file and are aware that the project type is Java. For example:

domain: example.com
layout:
- quarkus.javaoperatorsdk.io/v1-alpha
projectName: memcached-operator
version: "3"
Creating an API and controller
Use the Operator SDK CLI to create a custom resource definition (CRD) API and controller.

Run the following command to create an API:


Run the tree command to view the file structure:


Defining the API
Define the API for the Memcached custom resource (CR).

Edit the following files that were generated as part of the create api process:
Generating CRD manifests
After the API is defined with MemcachedSpec and MemcachedStatus files, you can generate CRD manifests.

Run the following command from the memcached-operator directory to generate the CRD:


Verify the contents of the CRD in the target/kubernetes/memcacheds.cache.example.com-v1.yml file as shown in the following example:
Creating a Custom Resource
After generating the CRD manifests, you can create the Custom Resource (CR).

Create a Memcached CR called memcached-sample.yaml:
Implementing the controller
After creating a new API and controller, you can implement the controller logic.

Append the following dependency to the pom.xml file:

For this example, replace the generated controller file MemcachedReconciler.java with following example implementation:


The next subsections explain how the controller in the example implementation watches resources and how the reconcile loop is triggered. You can skip these subsections to go directly to Running the Operator.

Reconcile loop
Every controller has a reconciler object with a Reconcile() method that implements the reconcile loop. The reconcile loop is passed the Deployment argument, as shown in the following example:

As shown in the following example, if the Deployment is null, the deployment needs to be created. After you create the Deployment, you can determine if reconciliation is necessary. If there is no need of reconciliation, return the value of UpdateControl.noUpdate(), otherwise, return the value of `UpdateControl.updateStatus(resource):

After getting the Deployment, get the current and required replicas, as shown in the following example:

If currentReplicas does not match the requiredReplicas, you must update the Deployment, as shown in the following example:

The following example shows how to obtain the list of pods and their names:

Check if resources were created and verify podnames with the Memcached resources. If a mismatch exists in either of these conditions, perform a reconciliation as shown in the following example:
Defining labelsForMemcached
labelsForMemcached is a utility to return a map of the labels to attach to the resources:

    private Map<String, String> labelsForMemcached(Memcached m) {
        Map<String, String> labels = new HashMap<>();
        labels.put("app", "memcached");
        labels.put("memcached_cr", m.getMetadata().getName());
        return labels;
    }
Define the createMemcachedDeployment
The createMemcachedDeployment method uses the fabric8 DeploymentBuilder class:

    private Deployment createMemcachedDeployment(Memcached m) {
        Deployment deployment = new DeploymentBuilder()
            .withMetadata(
                new ObjectMetaBuilder()
                    .withName(m.getMetadata().getName())
                    .withNamespace(m.getMetadata().getNamespace())
                    .build())
            .withSpec(
                new DeploymentSpecBuilder()
                    .withReplicas(m.getSpec().getSize())
                    .withSelector(
                        new LabelSelectorBuilder().withMatchLabels(labelsForMemcached(m)).build())
                    .withTemplate(
                        new PodTemplateSpecBuilder()
                            .withMetadata(
                                new ObjectMetaBuilder().withLabels(labelsForMemcached(m)).build())
                            .withSpec(
                                new PodSpecBuilder()
                                    .withContainers(
                                        new ContainerBuilder()
                                            .withImage("memcached:1.4.36-alpine")
                                            .withName("memcached")
                                            .withCommand("memcached", "-m=64", "-o", "modern", "-v")
                                            .withPorts(
                                                new ContainerPortBuilder()
                                                    .withContainerPort(11211)
                                                    .withName("memcached")
                                                    .build())
                                            .build())
                                    .build())
                            .build())
                    .build())
            .build();
      deployment.addOwnerReference(m);
      return deployment;
    }
Running the Operator
There are three ways you can use the Operator SDK CLI to build and run your Operator:

Run locally outside the cluster as a Go program.

Run as a deployment on the cluster.

Bundle your Operator and use Operator Lifecycle Manager (OLM) to deploy on the cluster.


Running locally outside the cluster
You can run your Operator project as a Go program outside of the cluster. This is useful for development purposes to speed up deployment and testing.

Run the following command to compile the Operator:

Run the following command to install the CRD to the default namespace:

Create a file called rbac.yaml as shown in the following example:

Run the following command to grant cluster-admin privileges to the memcached-quarkus-operator-operator by applying the rbac.yaml file:

Enter the following command to run the Operator:

Apply the memcached-sample.yaml file with the following command:


Run the following command to confirm that the pod has started:
Running as a deployment on the cluster
You can run your Operator project as a deployment on your cluster.

Run the following make commands to build and push the Operator image. Modify the IMG argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.

Run the following command to install the CRD to the default namespace:

Create a file called rbac.yaml as shown in the following example:

Run the following command to deploy the Operator:

Run the following command to grant cluster-admin privileges to the memcached-quarkus-operator-operator by applying the rbac.yaml file created in a previous step:

Run the following command to verify that the Operator is running:

Run the following command to apply the memcached-sample.yaml and create the memcached-sample pod:


Run the following command to confirm the pods have started:
Bundling an Operator and deploying with Operator Lifecycle Manager
Bundling an Operator
The Operator bundle format is the default packaging method for Operator SDK and Operator Lifecycle Manager (OLM). You can get your Operator ready for use on OLM by using the Operator SDK to build and push your Operator project as a bundle image.

Operator SDK CLI installed on a development workstation

OpenShift CLI (oc) v4.15+ installed

Operator project initialized by using the Operator SDK


Run the following make commands in your Operator project directory to build and push your Operator image. Modify the IMG argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.

Create your Operator bundle manifest by running the make bundle command, which invokes several commands, including the Operator SDK generate bundle and bundle validate subcommands:

Build and push your bundle image by running the following commands. OLM consumes Operator bundles using an index image, which reference one or more bundle images.
Deploying an Operator with Operator Lifecycle Manager
Operator Lifecycle Manager (OLM) helps you to install, update, and manage the lifecycle of Operators and their associated services on a Kubernetes cluster. OLM is installed by default on Red Hat OpenShift Container Platform and runs as a Kubernetes extension so that you can use the web console and the OpenShift CLI (oc) for all Operator lifecycle management functions without any additional tools.

The Operator bundle format is the default packaging method for Operator SDK and OLM. You can use the Operator SDK to quickly run a bundle image on OLM to ensure that it runs properly.

Operator SDK CLI installed on a development workstation

Operator bundle image built and pushed to a registry

OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use apiextensions.k8s.io/v1 CRDs, for example Red Hat OpenShift Container Platform 4.15)

Logged in to the cluster with oc using an account with cluster-admin permissions


Enter the following command to run the Operator on the cluster:
Additional resources
See Project layout for Java-based Operators to learn about the directory structures created by the Operator SDK.

If a cluster-wide egress proxy is configured, cluster administrators can override the proxy settings or inject a custom CA certificate for specific Operators running on Operator Lifecycle Manager (OLM).