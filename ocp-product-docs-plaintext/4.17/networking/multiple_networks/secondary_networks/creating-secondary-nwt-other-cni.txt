# Creating secondary networks with other CNI plugins


The specific configuration fields for additional networks are described in the following sections.

# Configuration for a bridge additional network

The following object describes the configuration parameters for the Bridge CNI plugin:




[NOTE]
----
The VLAN parameter configures the VLAN tag on the host end of the veth and also enables the vlan_filtering feature on the bridge interface.
----


[NOTE]
----
To configure an uplink for an L2 network, you must allow the VLAN on the uplink interface by using the following command:

```terminal
$  bridge vlan add vid VLAN_ID dev DEV
```

----

## Bridge CNI plugin configuration example

The following example configures an additional network named bridge-net:


```json
{
  "cniVersion": "0.3.1",
  "name": "bridge-net",
  "type": "bridge",
  "isGateway": true,
  "vlan": 2,
  "ipam": {
    "type": "dhcp"
    }
}
```


# Configuration for a host device additional network


[NOTE]
----
Specify your network device by setting only one of the following parameters: device,hwaddr, kernelpath, or pciBusID.
----

The following object describes the configuration parameters for the host-device CNI plugin:



## host-device configuration example

The following example configures an additional network named hostdev-net:


```json
{
  "cniVersion": "0.3.1",
  "name": "hostdev-net",
  "type": "host-device",
  "device": "eth1"
}
```


# Configuration for a VLAN additional network

The following object describes the configuration parameters for the VLAN, vlan, CNI plugin:




[IMPORTANT]
----
A NetworkAttachmentDefinition custom resource definition (CRD) with a vlan configuration can be used only on a single pod in a node because the CNI plugin cannot create multiple vlan subinterfaces with the same vlanId on the same master interface.
----

## VLAN configuration example

The following example demonstrates a vlan configuration with an additional network that is named vlan-net:


```json
{
  "name": "vlan-net",
  "cniVersion": "0.3.1",
  "type": "vlan",
  "master": "eth0",
  "mtu": 1500,
  "vlanId": 5,
  "linkInContainer": false,
  "ipam": {
      "type": "host-local",
      "subnet": "10.1.1.0/24"
  },
  "dns": {
      "nameservers": [ "10.1.1.1", "8.8.8.8" ]
  }
}
```


# Configuration for an IPVLAN additional network

The following object describes the configuration parameters for the IPVLAN, ipvlan, CNI plugin:




[IMPORTANT]
----
* The ipvlan object does not allow virtual interfaces to communicate with the master interface. Therefore the container is not able to reach the host by using the ipvlan interface. Be sure that the container joins a network that provides connectivity to the host, such as a network supporting the Precision Time Protocol (PTP).
* A single master interface cannot simultaneously be configured to use both macvlan and ipvlan.
* For IP allocation schemes that cannot be interface agnostic, the ipvlan plugin can be chained with an earlier plugin that handles this logic. If the master is omitted, then the previous result must contain a single interface name for the ipvlan plugin to enslave. If ipam is omitted, then the previous result is used to configure the ipvlan interface.
----

## IPVLAN CNI plugin configuration example

The following example configures an additional network named ipvlan-net:


```json
{
  "cniVersion": "0.3.1",
  "name": "ipvlan-net",
  "type": "ipvlan",
  "master": "eth1",
  "linkInContainer": false,
  "mode": "l3",
  "ipam": {
    "type": "static",
    "addresses": [
       {
         "address": "192.168.10.10/24"
       }
    ]
  }
}
```


# Configuration for a macvlan additional network

The following object describes the configuration parameters for the MACVLAN CNI plugin:




[NOTE]
----
If you specify the master key for the plugin configuration, use a different physical network interface than the one that is associated with your primary network plugin to avoid possible conflicts.
----

## MACVLAN CNI plugin configuration example

The following example configures an additional network named macvlan-net:


```json
{
  "cniVersion": "0.3.1",
  "name": "macvlan-net",
  "type": "macvlan",
  "master": "eth1",
  "linkInContainer": false,
  "mode": "bridge",
  "ipam": {
    "type": "dhcp"
    }
}
```


# Configuration for a TAP additional network

The following object describes the configuration parameters for the TAP CNI
plugin:



## Tap configuration example

The following example configures an additional network named mynet:


```json
{
 "name": "mynet",
 "cniVersion": "0.3.1",
 "type": "tap",
 "mac": "00:11:22:33:44:55",
 "mtu": 1500,
 "selinuxcontext": "system_u:system_r:container_t:s0",
 "multiQueue": true,
 "owner": 0,
 "group": 0
 "bridge": "br1"
}
```


## Setting SELinux boolean for the TAP CNI plugin

To create the tap device with the container_t SELinux context, enable the container_use_devices boolean on the host by using the Machine Config Operator (MCO).

* You have installed the OpenShift CLI (oc).

1. Create a new YAML file named, such as setsebool-container-use-devices.yaml, with the following details:

```yaml
apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 99-worker-setsebool
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
      - enabled: true
        name: setsebool.service
        contents: |
          [Unit]
          Description=Set SELinux boolean for the TAP CNI plugin
          Before=kubelet.service

          [Service]
          Type=oneshot
          ExecStart=/usr/sbin/setsebool container_use_devices=on
          RemainAfterExit=true

          [Install]
          WantedBy=multi-user.target graphical.target
```

2. Create the new MachineConfig object by running the following command:

```terminal
$ oc apply -f setsebool-container-use-devices.yaml
```


[NOTE]
----
Applying any changes to the MachineConfig object causes all affected nodes to gracefully reboot after the change is applied. This update can take some time to be applied.
----
3. Verify the change is applied by running the following command:

```terminal
$ oc get machineconfigpools
```

Expected output

```terminal
NAME        CONFIG                                                UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master      rendered-master-e5e0c8e8be9194e7c5a882e047379cfa      True      False      False      3              3                   3                     0                      7d2h
worker      rendered-worker-d6c9ca107fba6cd76cdcbfcedcafa0f2      True      False      False      3              3                   3                     0                      7d
```


[NOTE]
----
All nodes should be in the updated and ready state.
----

* For more information about enabling an SELinux boolean on a node, see Setting SELinux booleans.