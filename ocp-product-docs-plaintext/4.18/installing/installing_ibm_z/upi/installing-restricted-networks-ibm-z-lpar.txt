# Installing a cluster in an LPAR on IBM Z and IBM LinuxONE in a disconnected environment


In Red Hat OpenShift Container Platform version 4.18, you can install a cluster in a logical partition (LPAR) on IBM Z(R) or IBM(R) LinuxONE infrastructure that you provision in a disconnected environment.

[NOTE]
----
While this document refers to only IBM Z(R), all information in it also applies to IBM(R) LinuxONE.
----

# Prerequisites

* You have completed the tasks in Preparing to install a cluster on IBM Z using user-provisioned infrastructure.
* You reviewed details about the Red Hat OpenShift Container Platform installation and update processes.
* You read the documentation on selecting a cluster installation method and preparing it for users.
* You mirrored the images for a disconnected installation to your registry and obtained the imageContentSources data for your version of Red Hat OpenShift Container Platform.
* Before you begin the installation process, you must move or remove any existing installation files. This ensures that the required installation files are created and updated during the installation process.

[IMPORTANT]
----
Ensure that installation steps are done from a machine with access to the installation media.
----
* You provisioned persistent storage using OpenShift Data Foundation or other supported storage protocols for your cluster. To deploy a private image registry, you must set up persistent storage with ReadWriteMany access.
* If you use a firewall and plan to use the Telemetry service, you configured the firewall to allow the sites that your cluster requires access to.

[NOTE]
----
Be sure to also review this site list if you are configuring a proxy.
----

# About installations in restricted networks

In Red Hat OpenShift Container Platform 4.18, you can perform an installation that does not
require an active connection to the internet to obtain software components. Restricted network installations can be completed using installer-provisioned infrastructure or user-provisioned infrastructure, depending on the cloud platform to which you are installing the cluster.

If you choose to perform a restricted network installation on a cloud platform, you
still require access to its cloud APIs. Some cloud functions, like
Amazon Web Service&#8217;s Route 53 DNS and IAM services, require internet access.
Depending on your network, you might require less internet
access for an installation on bare metal hardware, Nutanix, or on VMware vSphere.

To complete a restricted network installation, you must create a registry that
mirrors the contents of the OpenShift image registry and contains the
installation media. You can create this registry on a mirror host, which can
access both the internet and your closed network, or by using other methods
that meet your restrictions.


[IMPORTANT]
----
Because of the complexity of the configuration for user-provisioned installations, consider completing a standard user-provisioned infrastructure installation before you attempt a restricted network installation using user-provisioned infrastructure. Completing this test installation might make it easier to isolate and troubleshoot any issues that might arise during your installation in a restricted network.
----

## Additional limits

Clusters in restricted networks have the following additional limitations and restrictions:

* The ClusterVersion status includes an Unable to retrieve available updates
error.
* By default, you cannot use the contents of the Developer Catalog because
you cannot access the required image stream tags.

# Preparing the user-provisioned infrastructure

To ensure a successful deployment and meet cluster requirements in Red Hat OpenShift Container Platform, prepare your user-provisioned infrastructure before starting the installation. Configuring your compute, network, and storage components in advance provides the stable foundation necessary for the installation program to function correctly.

This section provides details about the high-level steps required to set up your cluster infrastructure in preparation for an Red Hat OpenShift Container Platform installation. This includes configuring IP networking and network connectivity for your cluster nodes,
preparing a web server for the Ignition files,
enabling the required ports through your firewall, and setting up the required DNS and load balancing infrastructure.

After preparation, your cluster infrastructure must meet the requirements outlined in the Requirements for a cluster with user-provisioned infrastructure section.

* You have reviewed the Red Hat OpenShift Container Platform 4.x Tested Integrations page.
* You have reviewed the infrastructure requirements detailed in the Requirements for a cluster with user-provisioned infrastructure section.

1. Set up static IP addresses.
2. Set up an HTTP or HTTPS server to provide Ignition files to the cluster nodes.
3. Ensure that your network infrastructure provides the required network connectivity between the cluster components. See the Networking requirements for user-provisioned infrastructure section for details about the requirements.
4. Configure your firewall to enable the ports required for the Red Hat OpenShift Container Platform cluster components to communicate. See Networking requirements for user-provisioned infrastructure section for details about the ports that are required.

[IMPORTANT]
----
By default, port 1936 is accessible for an Red Hat OpenShift Container Platform cluster, because each control plane node needs access to this port.
Avoid using the Ingress load balancer to expose this port, because doing so might result in the exposure of sensitive information, such as statistics and metrics, related to Ingress Controllers.
----
5. Setup the required DNS infrastructure for your cluster.
1. Configure DNS name resolution for the Kubernetes API, the application wildcard, the bootstrap machine, the control plane machines, and the compute machines.
2. Configure reverse DNS resolution for the Kubernetes API, the bootstrap machine, the control plane machines, and the compute machines.

See the User-provisioned DNS requirements section for more information about the Red Hat OpenShift Container Platform DNS requirements.
6. Validate your DNS configuration.
1. From your installation node, run DNS lookups against the record names of the Kubernetes API, the wildcard routes, and the cluster nodes. Validate that the IP addresses in the responses correspond to the correct components.
2. From your installation node, run reverse DNS lookups against the IP addresses of the load balancer and the cluster nodes. Validate that the record names in the responses correspond to the correct components.

See the Validating DNS resolution for user-provisioned infrastructure section for detailed DNS validation steps.
7. Provision the required API and application ingress load balancing infrastructure. See the Load balancing requirements for user-provisioned infrastructure section for more information about the requirements.

[NOTE]
----
Some load balancing solutions require the DNS name resolution for the cluster nodes to be in place before the load balancing is initialized.
----

## Example load balancer configuration for user-provisioned clusters

Reference the example API and application Ingress load balancer configuration so that you can understand how to meet the load balancing requirements for user-provisioned clusters.

The sample is an /etc/haproxy/haproxy.cfg configuration for an HAProxy load balancer. The example is not meant to provide advice for choosing one load balancing solution over another.


[TIP]
----
If you are using HAProxy as a load balancer, you can check that the haproxy process is listening on ports 6443, 22623, 443, and 80 by running netstat -nltupe on the HAProxy node.
----

In the example, the same load balancer is used for the Kubernetes API and application ingress traffic. In production scenarios, you can deploy the API and application ingress load balancers separately so that you can scale the load balancer infrastructure for each in isolation.


[NOTE]
----
If you are using HAProxy as a load balancer and SELinux is set to enforcing, you must ensure that the HAProxy service can bind to the configured TCP port by running setsebool -P haproxy_connect_any=1.
----


```text
global
  log         127.0.0.1 local2
  pidfile     /var/run/haproxy.pid
  maxconn     4000
  daemon
defaults
  mode                    http
  log                     global
  option                  dontlognull
  option http-server-close
  option                  redispatch
  retries                 3
  timeout http-request    10s
  timeout queue           1m
  timeout connect         10s
  timeout client          1m
  timeout server          1m
  timeout http-keep-alive 10s
  timeout check           10s
  maxconn                 3000
listen api-server-6443
  bind *:6443
  mode tcp
  option  httpchk GET /readyz HTTP/1.0
  option  log-health-checks
  balance roundrobin
  server bootstrap bootstrap.ocp4.example.com:6443 verify none check check-ssl inter 10s fall 2 rise 3 backup
  server master0 master0.ocp4.example.com:6443 weight 1 verify none check check-ssl inter 10s fall 2 rise 3
  server master1 master1.ocp4.example.com:6443 weight 1 verify none check check-ssl inter 10s fall 2 rise 3
  server master2 master2.ocp4.example.com:6443 weight 1 verify none check check-ssl inter 10s fall 2 rise 3
listen machine-config-server-22623
  bind *:22623
  mode tcp
  server bootstrap bootstrap.ocp4.example.com:22623 check inter 1s backup
  server master0 master0.ocp4.example.com:22623 check inter 1s
  server master1 master1.ocp4.example.com:22623 check inter 1s
  server master2 master2.ocp4.example.com:22623 check inter 1s
listen ingress-router-443
  bind *:443
  mode tcp
  balance source
  server compute0 compute0.ocp4.example.com:443 check inter 1s
  server compute1 compute1.ocp4.example.com:443 check inter 1s
listen ingress-router-80
  bind *:80
  mode tcp
  balance source
  server compute0 compute0.ocp4.example.com:80 check inter 1s
  server compute1 compute1.ocp4.example.com:80 check inter 1s
```


where:

listen api-server-6443:: Port 6443 handles the Kubernetes API traffic and points to the control plane machines.
server bootstrap bootstrap.ocp4.example.com:: The bootstrap entries must be in place before the Red Hat OpenShift Container Platform cluster installation and they must be removed after the bootstrap process is complete.
listen machine-config-server:: Port 22623 handles the machine config server traffic and points to the control plane machines.
listen ingress-router-443:: Port 443 handles the HTTPS traffic and points to the machines that run the Ingress Controller pods. The Ingress Controller pods run on the compute machines by default.
listen ingress-router-80:: Port 80 handles the HTTP traffic and points to the machines that run the Ingress Controller pods. The Ingress Controller pods run on the compute machines by default.

[NOTE]
----
If you are deploying a three-node cluster with zero compute nodes, the Ingress Controller pods run on the control plane nodes. In three-node cluster deployments, you must configure your application Ingress load balancer to route HTTP and HTTPS traffic to the control plane nodes.
----

# Manually creating the installation configuration file

To customise your Red Hat OpenShift Container Platform deployment and meet specific network requirements, manually create the installation configuration file. This ensures that the installation program uses your tailored settings rather than default values during the setup process.

* You have an SSH public key on your local machine for use with the installation program. You can use the key for SSH authentication onto your cluster nodes for debugging and disaster recovery.
* You have obtained the Red Hat OpenShift Container Platform installation program and the pull secret for your
cluster.

1. Create an installation directory to store your required installation assets in:

```terminal
$ mkdir <installation_directory>
```


[IMPORTANT]
----
You must create a directory. Some installation assets, such as bootstrap X.509 certificates have short expiration intervals, so you must not reuse an installation directory. If you want to reuse individual files from another cluster installation, you can copy them into your directory. However, the file names for the installation assets might change between releases. Use caution when copying installation files from an earlier Red Hat OpenShift Container Platform version.
----
2. Customize the provided sample install-config.yaml file template and save the file in the <installation_directory>.

[NOTE]
----
You must name this configuration file install-config.yaml.
----
3. Back up the install-config.yaml file so that you can use it to install many clusters.

[IMPORTANT]
----
Back up the install-config.yaml file now, because the installation process consumes the file in the next step.
----

* Installation configuration parameters for IBM Z(R)

## Sample install-config.yaml file for IBM Z

You can customize the install-config.yaml file to specify more details about your Red Hat OpenShift Container Platform cluster platform or modify the values of the required parameters.


```yaml
apiVersion: v1
baseDomain: example.com
compute:
- hyperthreading: Enabled
  name: worker
  replicas: 0
  architecture: s390x
controlPlane:
  hyperthreading: Enabled
  name: master
  replicas: 3
  architecture: s390x
metadata:
  name: test
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: 23
  networkType: OVNKubernetes
  serviceNetwork:
  - 172.30.0.0/16
platform:
  none: {}
fips: false
pullSecret: '{"auths":{"<local_registry>": {"auth": "<credentials>","email": "you@example.com"}}}'
sshKey: 'ssh-ed25519 AAAA...'
additionalTrustBundle: |
  -----BEGIN CERTIFICATE-----
  ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
  -----END CERTIFICATE-----
imageContentSources:
- mirrors:
  - <local_repository>/ocp4/openshift4
  source: quay.io/openshift-release-dev/ocp-release
- mirrors:
  - <local_repository>/ocp4/openshift4
  source: quay.io/openshift-release-dev/ocp-v4.0-art-dev
```


where:

baseDomain:: Specifies the base domain of the cluster. All DNS records must be sub-domains of this base and include the cluster name.
compute:: Specifies the compute node configurations, which is a sequence of mappings. To meet the requirements of the different data structures, the first line of the compute section must begin with a hyphen, -.
controlPlane:: Specifies the controlPlane node configurations, which is a single mapping. To meet the requirements of the different data structures, the first line of the controlPlane section must not. Only one control plane pool is used.
hyperthreading:: Specifies whether to enable or disable simultaneous multithreading (SMT), or hyperthreading. By default, SMT is enabled to increase the performance of the cores in your machines. You can disable it by setting the parameter value to Disabled. If you disable SMT, you must disable it in all cluster machines; this includes both control plane and compute machines.


[NOTE]
----
Simultaneous multithreading (SMT) is enabled by default. If SMT is not available on your Red Hat OpenShift Container Platform nodes, the hyperthreading parameter has no effect.
----


[IMPORTANT]
----
If you disable hyperthreading, whether on your Red Hat OpenShift Container Platform nodes or in the install-config.yaml file, ensure that your capacity planning accounts for the dramatically decreased machine performance.
----

compute.replicas:: Specifies the number of compute machines that the cluster creates and manages for you on installer-provisioned installations. You must set this value to 0 when you install Red Hat OpenShift Container Platform on user-provisioned infrastructure. Additionally for user-provisioned installations, you must manually deploy the compute machines before you finish installing the cluster.


[NOTE]
----
If you are installing a three-node cluster, do not deploy any compute machines when you install the Red Hat Enterprise Linux CoreOS (RHCOS) machines.
----

controlPlane.replicas:: Specifies the number of control plane machines that you add to the cluster. Because the cluster uses these values as the number of etcd endpoints in the cluster, the value must match the number of control plane machines that you deploy.
metadata.name:: Specifies the cluster name that you specified in your DNS records.
clusterNetwork.cidr:: Specifies a block of IP addresses from which pod IP addresses are allocated. This block must not overlap with existing physical networks. These IP addresses are used for the pod network. If you need to access the pods from an external network, you must configure load balancers and routers to manage the traffic.


[NOTE]
----
Class E CIDR range is reserved for a future use. To use the Class E CIDR range, you must ensure your networking environment accepts the IP addresses within the Class E CIDR range.
----

cidr.hostPrefix:: Specifies the subnet prefix length to assign to each individual node. For example, if hostPrefix is set to 23, then each node is assigned a /23 subnet out of the given cidr, which allows for 510 (2^(32 - 23) - 2) pod IP addresses. If you are required to provide access to nodes from an external network, configure load balancers and routers to manage the traffic.
networkType:: Specifies the cluster network plugin to install. The default value OVNKubernetes is the only supported value.
serviceNetwork:: Specifies the IP address pool to use for service IP addresses. You can enter only one IP address pool. This block must not overlap with existing physical networks. If you need to access the services from an external network, configure load balancers and routers to manage the traffic.
platform:: Specifies the platform. You must set the platform to none. You cannot provide additional platform configuration variables for
IBM Z(R) infrastructure.


[IMPORTANT]
----
Clusters that are installed with the platform type none are unable to use some features, such as managing compute machines with the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that would normally support the feature. This parameter cannot be changed after installation.
----

fips:: Specifies either enabling or disabling FIPS mode. By default, FIPS mode is not enabled. If FIPS mode is enabled, the Red Hat Enterprise Linux CoreOS (RHCOS) machines that Red Hat OpenShift Container Platform runs on bypass the default Kubernetes cryptography suite and use the cryptography modules that are provided with RHCOS instead.


[IMPORTANT]
----
To enable FIPS mode for your cluster, you must run the installation program from a Red Hat Enterprise Linux (RHEL) computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see Switching RHEL to FIPS mode.
When running Red Hat Enterprise Linux (RHEL) or Red Hat Enterprise Linux CoreOS (RHCOS) booted in FIPS mode, Red Hat OpenShift Container Platform core components use the RHEL cryptographic libraries that have been submitted to NIST for FIPS 140-2/140-3 Validation on only the x86_64, ppc64le, and s390x architectures.
----

pullSecret:: Specifies the registry domain name for <local_registry>, and optionally the port, that your mirror registry uses to serve content. For example, registry.example.com or registry.example.com:5000. For <credentials>, specify the base64-encoded user name and password for your mirror registry.
sshKey:: Specifies the SSH public key for the core user in Red Hat Enterprise Linux CoreOS (RHCOS).


[NOTE]
----
For production Red Hat OpenShift Container Platform clusters on which you want to perform installation debugging or disaster recovery, specify an SSH key that your ssh-agent process uses.
----

additionalTrustBundle:: Specifies the additionalTrustBundle parameter and value. The value must be the contents of the certificate file that you used for your mirror registry. The certificate file can be an existing, trusted certificate authority or the self-signed certificate that you generated for the mirror registry.
imageContentSources:: Specifies the imageContentSources section according to the output of the command that you used to mirror the repository.


[IMPORTANT]
----
* When using the oc adm release mirror command, use the output from the imageContentSources section.
* When using oc mirror command, use the repositoryDigestMirrors section of the ImageContentSourcePolicy file that results from running the command.
* ImageContentSourcePolicy is deprecated. For more information see Configuring image registry repository mirroring.
----

## Configuring the cluster-wide proxy during installation

To enable internet access in environments that deny direct connections, configure a cluster-wide proxy in the install-config.yaml file. This configuration ensures that the new Red Hat OpenShift Container Platform cluster routes traffic through the specified HTTP or HTTPS proxy.

* You have an existing install-config.yaml file.
* You have reviewed the sites that your cluster requires access to and determined whether any of them need to bypass the proxy. By default, all cluster egress traffic is proxied, including calls to hosting cloud provider APIs. You added sites to the Proxy object's spec.noProxy field to bypass the proxy if necessary.

[NOTE]
----
The Proxy object status.noProxy field is populated with the values of the networking.machineNetwork[].cidr, networking.clusterNetwork[].cidr, and networking.serviceNetwork[] fields from your installation configuration.
For installations on Amazon Web Services (AWS), Google Cloud Platform (GCP), Microsoft Azure, and Red Hat OpenStack Platform (RHOSP), the Proxy object status.noProxy field is also populated with the instance metadata endpoint (169.254.169.254).
----

1. Edit your install-config.yaml file and add the proxy settings. For example:

```yaml
apiVersion: v1
baseDomain: my.domain.com
proxy:
  httpProxy: http://<username>:<pswd>@<ip>:<port>
  httpsProxy: https://<username>:<pswd>@<ip>:<port>
  noProxy: example.com
additionalTrustBundle: |
    -----BEGIN CERTIFICATE-----
    <MY_TRUSTED_CA_CERT>
    -----END CERTIFICATE-----
additionalTrustBundlePolicy: <policy_to_add_additionalTrustBundle>
# ...
```


where:
proxy.httpProxy:: Specifies a proxy URL to use for creating HTTP connections outside the cluster. The URL scheme must be http.
proxy.httpsProxy:: Specifies a proxy URL to use for creating HTTPS connections outside the cluster.
proxy.noProxy:: Specifies a comma-separated list of destination domain names, IP addresses, or other network CIDRs to exclude from proxying. Preface a domain with . to match subdomains only. For example, .y.com matches x.y.com, but not y.com. Use * to bypass the proxy for all destinations.
additionalTrustBundle:: If provided, the installation program generates a config map that is named user-ca-bundle inthe openshift-config namespace to hold the additional CA certificates. If you provide additionalTrustBundle and at least one proxy setting, the Proxy object is configured to reference the user-ca-bundle config map in the trustedCA field. The Cluster Network Operator then creates a trusted-ca-bundle config map that merges the contents specified for the trustedCA parameter with the RHCOS trust bundle. The additionalTrustBundle field is required unless the proxy's identity certificate is signed by an authority from the RHCOS trust bundle.
additionalTrustBundlePolicy:: Specifies the policy that determines the configuration of the Proxy object to reference the user-ca-bundle config map in the trustedCA field. The allowed values are Proxyonly and Always. Use Proxyonly to reference the user-ca-bundle config map only when http/https proxy is configured. Use Always to always reference the user-ca-bundle config map. The default value is Proxyonly. Optional parameter.

[NOTE]
----
The installation program does not support the proxy readinessEndpoints field.
----

[NOTE]
----
If the installer times out, restart and then complete the deployment by using the wait-for command of the installer. For example:
+

```terminal
$ ./openshift-install wait-for install-complete --log-level debug
```

----
2. Save the file and reference it when installing Red Hat OpenShift Container Platform.

The installation program creates a cluster-wide proxy that is named cluster that uses the proxy settings in the provided install-config.yaml file. If no proxy settings are provided, a cluster Proxy object is still created, but it will have a nil spec.

[NOTE]
----
Only the Proxy object named cluster is supported, and no additional proxies can be created.
----

## Configuring a three-node cluster

To create smaller, resource-efficient clusters for testing and production, deploy a bare-metal cluster with zero compute machines. This optional configuration uses only three control plane machines, optimizing infrastructure resources for administrators and developers.

In three-node Red Hat OpenShift Container Platform environments, the three control plane machines are schedulable, which means that your application workloads are scheduled to run on them.

* You have an existing install-config.yaml file.

* Ensure that the number of compute replicas is set to 0 in your install-config.yaml file, as shown in the following compute stanza:

```yaml
compute:
- name: worker
  platform: {}
  replicas: 0
# ...
```


[NOTE]
----
You must set the value of the replicas parameter for the compute machines to 0 when you install Red Hat OpenShift Container Platform on user-provisioned infrastructure, regardless of the number of compute machines you are deploying. In installer-provisioned installations, the parameter controls the number of compute machines that the cluster creates and manages for you. This does not apply to user-provisioned installations, where the compute machines are deployed manually.
----

For three-node cluster installations, follow these next steps:

* If you are deploying a three-node cluster with zero compute nodes, the Ingress Controller pods run on the control plane nodes. In three-node cluster deployments, you must configure your application ingress load balancer to route HTTP and HTTPS traffic to the control plane nodes. See the Load balancing requirements for user-provisioned infrastructure section for more information.
* When you create the Kubernetes manifest files in the following procedure, ensure that the mastersSchedulable parameter in the <installation_directory>/manifests/cluster-scheduler-02-config.yml file is set to true. This enables your application workloads to run on the control plane nodes.
* Do not deploy any compute nodes when you create the Red Hat Enterprise Linux CoreOS (RHCOS) machines.

# Cluster Network Operator configuration

The configuration for the cluster network is specified as part of the Cluster Network Operator (CNO) configuration and stored in a custom resource (CR) object that is named cluster. The CR specifies the fields for the Network API in the operator.openshift.io API group.

The CNO configuration inherits the following fields during cluster installation from the Network API in the Network.config.openshift.io API group:

clusterNetwork:: IP address pools from which pod IP addresses are allocated.
serviceNetwork:: IP address pool for services.
defaultNetwork.type:: Cluster network plugin. OVNKubernetes is the only supported plugin during installation.

You can specify the cluster network plugin configuration for your cluster by setting the fields for the defaultNetwork object in the CNO object named cluster.

## Cluster Network Operator configuration object

The fields for the Cluster Network Operator (CNO) are described in the following table:




[IMPORTANT]
----
For a cluster that needs to deploy objects across multiple networks, ensure that you specify the same value for the clusterNetwork.hostPrefix parameter for each network type that is defined in the install-config.yaml file. Setting a different value for each clusterNetwork.hostPrefix parameter can impact the OVN-Kubernetes network plugin, where the plugin cannot effectively route object traffic among different nodes.
----

### defaultNetwork object configuration

The values for the defaultNetwork object are defined in the following table:



#### Configuration for the OVN-Kubernetes network plugin

The following table describes the configuration fields for the OVN-Kubernetes network plugin:


















```yaml
defaultNetwork:
  type: OVNKubernetes
  ovnKubernetesConfig:
    mtu: 1400
    genevePort: 6081
    ipsecConfig:
      mode: Full
```


# Creating the Kubernetes manifest and Ignition config files

To customize cluster definitions and manually start machines, generate the Kubernetes manifest and Ignition config files. These assets provide the necessary instructions to configure the cluster infrastructure according to your specific deployment requirements.

The installation configuration file transforms into the Kubernetes manifests. The manifests wrap into the Ignition configuration files, which are later used to configure the cluster machines.


[IMPORTANT]
----
* The Ignition config files that the Red Hat OpenShift Container Platform installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending node-bootstrapper certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for Recovering from expired control plane certificates for more information.
* It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.
----


[NOTE]
----
The installation program that generates the manifest and Ignition files is architecture specific and can be obtained from the
client image mirror. The Linux version of the installation program runs on s390x only. This installer program is also available as a macOS version.
----

* You obtained the Red Hat OpenShift Container Platform installation program.
For a restricted network installation, these files are on your mirror host.
* You created the install-config.yaml installation configuration file.

1. Change to the directory that contains the Red Hat OpenShift Container Platform installation program and generate the Kubernetes manifests for the cluster:

```terminal
$ ./openshift-install create manifests --dir <installation_directory>
```


where
<installation_directory>:: Specifies the installation directory that contains the install-config.yaml file you created.

[WARNING]
----
If you are installing a three-node cluster, skip the following step to allow the control plane nodes to be schedulable.
----

+

[IMPORTANT]
----
When you configure control plane nodes from the default unschedulable to schedulable, additional subscriptions are required. This is because control plane nodes then become compute nodes.
----
2. Check that the mastersSchedulable parameter in the <installation_directory>/manifests/cluster-scheduler-02-config.yml Kubernetes manifest file is set to false. This setting prevents pods from being scheduled on the control plane machines:
1. Open the <installation_directory>/manifests/cluster-scheduler-02-config.yml file.
2. Locate the mastersSchedulable parameter and ensure that it is set to false.
3. Save and exit the file.
3. To create the Ignition configuration files, run the following command from the directory that contains the installation program:

```terminal
$ ./openshift-install create ignition-configs --dir <installation_directory>
```


where:
<installation_directory>:: Specifies the same installation directory.

Ignition config files are created for the bootstrap, control plane, and compute nodes in the installation directory. The kubeadmin-password and kubeconfig files are created in the ./<installation_directory>/auth directory:

```
.
├── auth
│   ├── kubeadmin-password
│   └── kubeconfig
├── bootstrap.ign
├── master.ign
├── metadata.json
└── worker.ign
```


# Configuring NBDE with static IP in an IBM Z or IBM LinuxONE environment

Enabling NBDE disk encryption in an IBM Z&#174; or IBM&#174; LinuxONE environment requires additional steps, which are described in detail in this section.

* You have set up the External Tang Server. See Network-bound disk encryption for instructions.
* You have installed the butane utility.
* You have reviewed the instructions for how to create machine configs with Butane.

1. Create Butane configuration files for the control plane and compute nodes.

The following example of a Butane configuration for a control plane node creates a file named master-storage.bu for disk encryption:

```yaml
variant: openshift
version: 4.18.0
metadata:
  name: master-storage
  labels:
    machineconfiguration.openshift.io/role: master
storage:
  luks:
    - clevis:
        tang:
          - thumbprint: QcPr_NHFJammnRCA3fFMVdNBwjs
            url: http://clevis.example.com:7500
        options: 1
           - --cipher
           - aes-cbc-essiv:sha256
      device: /dev/disk/by-partlabel/root 2
      label: luks-root
      name: root
      wipe_volume: true
  filesystems:
    - device: /dev/mapper/root
      format: xfs
      label: root
      wipe_filesystem: true
openshift:
  fips: true 3
```

The cipher option is only required if FIPS mode is enabled. Omit the entry if FIPS is disabled.
For installations on DASD-type disks, replace with device: /dev/disk/by-label/root.
Whether to enable or disable FIPS mode. By default, FIPS mode is not enabled. If FIPS mode is enabled, the Red Hat Enterprise Linux CoreOS (RHCOS) machines that Red Hat OpenShift Container Platform runs on bypass the default Kubernetes cryptography suite and use the cryptography modules that are provided with RHCOS instead.
2. Create a customized initramfs file to boot the machine, by running the following command:

```terminal
$ coreos-installer pxe customize \
    /root/rhcos-bootfiles/rhcos-<release>-live-initramfs.s390x.img \
    --dest-device /dev/disk/by-id/scsi-<serial_number> --dest-karg-append \
    ip=<ip_address>::<gateway_ip>:<subnet_mask>::<network_device>:none \
    --dest-karg-append nameserver=<nameserver_ip> \
    --dest-karg-append rd.neednet=1 -o \
    /root/rhcos-bootfiles/<node_name>-initramfs.s390x.img
```


[NOTE]
----
Before first boot, you must customize the initramfs for each node in the cluster, and add PXE kernel parameters.
----
3. Create a parameter file that includes ignition.platform.id=metal and ignition.firstboot.
Example kernel parameter file for the control plane machine

```terminal
cio_ignore=all,!condev rd.neednet=1 \
console=ttysclp0 \
coreos.inst.install_dev=/dev/<block_device> \1
ignition.firstboot ignition.platform.id=metal \
coreos.inst.ignition_url=http://<http_server>/master.ign \2
coreos.live.rootfs_url=http://<http_server>/rhcos-<version>-live-rootfs.<architecture>.img \3
ip=<ip>::<gateway>:<netmask>:<hostname>::none nameserver=<dns> \
rd.znet=qeth,0.0.bdd0,0.0.bdd1,0.0.bdd2,layer2=1 \
rd.zfcp=0.0.5677,0x600606680g7f0056,0x034F000000000000 \4
zfcp.allow_lun_scan=0
```

Specify the block device type. For installations on DASD-type disks, specify /dev/dasda. For installations on FCP-type disks, specify /dev/sda. For installations on NVMe-type disks, specify /dev/nvme0n1.
Specify the location of the Ignition config file. Use master.ign or worker.ign. Only HTTP and HTTPS protocols are supported.
Specify the location of the rootfs artifact for the kernel and initramfs you are booting. Only HTTP and HTTPS protocols are supported.
For installations on DASD-type disks, replace with rd.dasd=0.0.xxxx to specify the DASD device.

[NOTE]
----
Write all options in the parameter file as a single line and make sure you have no newline characters.
----

* Creating machine configs with Butane

# Installing RHCOS and starting the Red Hat OpenShift Container Platform bootstrap process

To install Red Hat OpenShift Container Platform on IBM Z&#174; infrastructure that you provision, you must install Red Hat Enterprise Linux CoreOS (RHCOS) in an LPAR. When you install RHCOS, you must provide the Ignition config file that was generated by the Red Hat OpenShift Container Platform installation program for the type of machine you are installing. If you have configured suitable networking, DNS, and load balancing infrastructure, the Red Hat OpenShift Container Platform bootstrap process begins automatically after the RHCOS guest machines have rebooted.

Complete the following steps to create the machines.

* An HTTP or HTTPS server running on your provisioning machine that is accessible to the machines you create.
* If you want to enable secure boot, you have obtained the appropriate Red Hat Product Signing Key and read Secure boot on IBM Z and IBM LinuxONE in IBM documentation.

1. Log in to Linux on your provisioning machine.
2. Obtain the Red Hat Enterprise Linux CoreOS (RHCOS) kernel, initramfs, and rootfs files from the RHCOS image mirror.

[IMPORTANT]
----
The RHCOS images might not change with every release of Red Hat OpenShift Container Platform.
You must download images with the highest version that is less than or equal
to the Red Hat OpenShift Container Platform version that you install. Only use the appropriate kernel, initramfs, and rootfs artifacts described in the following procedure.
----

The file names contain the Red Hat OpenShift Container Platform version number. They resemble the following examples:
* kernel: rhcos-<version>-live-kernel-<architecture>
* initramfs: rhcos-<version>-live-initramfs.<architecture>.img
* rootfs: rhcos-<version>-live-rootfs.<architecture>.img

[NOTE]
----
The rootfs image is the same for FCP and DASD.
----
3. Create parameter files. The following parameters are specific for a particular virtual machine:
* For ip=, specify the following seven entries:
1. The IP address for the machine.
2. An empty string.
3. The gateway.
4. The netmask.
5. The machine host and domain name in the form hostname.domainname. If you omit this value, RHCOS obtains the hostname through a reverse DNS lookup.
6. The network interface name. If you omit this value, RHCOS applies the IP configuration to all available interfaces.
7. If you use static IP addresses, specify none.
* For coreos.inst.ignition_url=, specify the Ignition file for the machine role. Use bootstrap.ign, master.ign, or worker.ign. Only HTTP and HTTPS protocols are supported.
* For coreos.live.rootfs_url=, specify the matching rootfs artifact for the kernel and initramfs you are booting. Only HTTP and HTTPS protocols are supported.
* Optional: To enable secure boot, add coreos.inst.secure_ipl
* For installations on DASD-type disks, complete the following tasks:
1. For coreos.inst.install_dev=, specify /dev/disk/by-path/ccw-<device_id>. For <device_id> specify, for example, 0.0.1000.
2. Use rd.dasd= to specify the DASD where RHCOS is to be installed.
3. Leave all other parameters unchanged.

Example parameter file, bootstrap-0.parm, for the bootstrap machine:

```terminal
cio_ignore=all,!condev rd.neednet=1 \
console=ttysclp0 \
coreos.inst.install_dev=/dev/disk/by-id/scsi-<serial_number> \1
coreos.inst.ignition_url=http://<http_server>/bootstrap.ign \2
coreos.live.rootfs_url=http://<http_server>/rhcos-<version>-live-rootfs.<architecture>.img \3
coreos.inst.secure_ipl \4
ip=<ip>::<gateway>:<netmask>:<hostname>::none nameserver=<dns> \
rd.znet=qeth,0.0.bdf0,0.0.bdf1,0.0.bdf2,layer2=1,portno=0 \
rd.dasd=0.0.3490
```

Specify a unique fully qualified path depending on disk type. This can be either DASD-type, FCP-type, or NVMe-type disks.
Specify the location of the Ignition config file. Use bootstrap.ign, master.ign, or worker.ign. Only HTTP and HTTPS protocols are supported.
Specify the location of the rootfs artifact for the kernel and initramfs you are booting. Only HTTP and HTTPS protocols are supported.
Optional: To enable secure boot, add coreos.inst.secure_ipl.

Write all options in the parameter file as a single line and make sure you have no newline characters.
* For installations on FCP-type disks, complete the following tasks:
1. Use rd.zfcp=<adapter>,<wwpn>,<lun> to specify the FCP disk where RHCOS is to be installed. For multipathing repeat this step for each additional path.

[NOTE]
----
When you install with multiple paths, you must enable multipathing directly after the installation, not at a later point in time, as this can cause problems.
----
2. Set the install device as: coreos.inst.install_dev=/dev/disk/by-id/scsi-<serial_number>.
4. Optional: Create a generic.ins file:

Some installation methods also require a generic.ins file with a mapping of the location of the installation data in the file system of the Hardware Management Console (HMC), the DVD, or the FTP server and the memory locations where the data is to be copied. A sample generic.ins file is provided with the RHEL installation media. The file contains file names for the initial RAM disk (initrd.img), the kernel image (kernel.img), and the parameter (generic.prm) files and a memory location for each file.
Example generic.ins file

```terminal
images/kernel.img 0x00000000
images/initrd.img 0x02000000
images/genericdvd.prm 0x00010480
images/initrd.addrsize 0x00010408
```

5. Leave all other parameters unchanged.

[IMPORTANT]
----
Additional postinstallation steps are required to fully enable multipathing. For more information, see “Enabling multipathing with kernel arguments on RHCOS" in Machine configuration.
----

The following is an example parameter file worker-1.parm for a compute node with multipathing:

```terminal
cio_ignore=all,!condev rd.neednet=1 \
console=ttysclp0 \
coreos.inst.install_dev=/dev/disk/by-id/scsi-<serial_number> \
coreos.live.rootfs_url=http://<http_server>/rhcos-<version>-live-rootfs.<architecture>.img \
coreos.inst.ignition_url=http://<http_server>/worker.ign \
ip=<ip>::<gateway>:<netmask>:<hostname>::none nameserver=<dns> \
rd.znet=qeth,0.0.bdf0,0.0.bdf1,0.0.bdf2,layer2=1,portno=0 \
rd.zfcp=0.0.1987,0x50050763070bc5e3,0x4008400B00000000 \
rd.zfcp=0.0.19C7,0x50050763070bc5e3,0x4008400B00000000 \
rd.zfcp=0.0.1987,0x50050763071bc5e3,0x4008400B00000000 \
rd.zfcp=0.0.19C7,0x50050763071bc5e3,0x4008400B00000000
```


Write all options in the parameter file as a single line and make sure you have no newline characters.
6. Transfer the initramfs, kernel, parameter files, and RHCOS images to the LPAR, for example with FTP. For details about how to transfer the files with FTP and boot, see Booting the installation on IBM Z(R) to install RHEL in an LPAR.
7. Boot the machine
8. Repeat this procedure for the other machines in the cluster.

## Networking and bonding options for ISO installations

You can configure advanced options so that you can modify the Red Hat Enterprise Linux CoreOS (RHCOS) manual installation process. The subsequent sections show examples of networking options for an ISO installation.

If you install RHCOS from an ISO image, you can add kernel arguments manually when you boot the image to configure networking for a node. If no networking arguments are specified, DHCP is activated in the initramfs when RHCOS detects that networking is required to fetch the Ignition config file.


[IMPORTANT]
----
When adding networking arguments manually, you must also add the rd.neednet=1 kernel argument to bring the network up in the initramfs.
----

The following information provides examples for configuring networking and bonding on your RHCOS nodes for ISO installations. The examples describe how to use the ip=, nameserver=, and bond= kernel arguments.


[NOTE]
----
Ordering is important when adding the kernel arguments: ip=, nameserver=, and then bond=.
----

The networking options are passed to the dracut tool during system boot. For more information about the networking options supported by dracut, see dracut.cmdline manual page.

* dracut.cmdline manual page

### Configuring DHCP or static IP addresses

You can configure an IP address by using either DHCP or an individual static IP address. If you set a static IP, you must then identify the DNS server IP address on each node.

The configuration examples in the procedure, update the IP addresses for the following components:

* The node's IP address to 10.10.10.2
* The gateway address to 10.10.10.254
* The netmask to 255.255.255.0
* The hostname to core0.example.com
* The DNS server address to 4.4.4.41
* The auto-configuration value to none. No auto-configuration is required when IP networking is configured statically.

1. Enter a command like the following command to configure a static IP address:

```terminal
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:enp1s0:none
nameserver=4.4.4.41
```

2. Enter a command like the following command to configure a DHCP IP address:

```terminal
ip=enp1s0:dhcp
```


[NOTE]
----
When you use DHCP to configure IP addressing for the RHCOS machines, the machines also obtain the DNS server information through DHCP. For DHCP-based deployments, you can define the DNS server address that is used by the RHCOS nodes through your DHCP server configuration.
----
3. If two or more network interfaces and only one interface exists, disable DHCP on a single interface. In the example, the enp1s0 interface has a static networking configuration and DHCP is disabled for enp2s0, which is not used:

```terminal
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:enp1s0:none
ip=::::core0.example.com:enp2s0:none
```

4. If you need to combine DHCP and static IP configurations on systems with multiple network interfaces, run the following example command:

```terminal
ip=enp1s0:dhcp
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:enp2s0:none
```


### Configuring an IP address without a static hostname

You can configure an IP address without assigning a static hostname. If a static hostname is not set by the user, the static hostname gets picked up and automatically set by a reverse DNS lookup.

The configuration examples in the procedure, update the IP addresses for the following components:

* The node's IP address to 10.10.10.2
* The gateway address to 10.10.10.254
* The netmask to 255.255.255.0
* The DNS server address to 4.4.4.41
* The auto-configuration value to none. No auto-configuration is required when IP networking is configured statically.

* To configure an IP address without a static hostname, enter a command like the following command:

```terminal
ip=10.10.10.2::10.10.10.254:255.255.255.0::enp1s0:none
nameserver=4.4.4.41
```


### Specifying multiple network interfaces and DNS servers

You can specify multiple network interfaces by setting multiple ip= entries. You can provide multiple DNS servers by adding a nameserver= entry for each server,

* To specify multiple network interfaces for your interfaces, you can enter a command like the following command:

```terminal
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:enp1s0:none
ip=10.10.10.3::10.10.10.254:255.255.255.0:core0.example.com:enp2s0:none
```

* To provide multiple DNS servers by adding a nameserver= entry for each server, enter a command like the following command:

```terminal
nameserver=1.1.1.1
nameserver=8.8.8.8
```


### Configuring default gateway and route

As an optional task, you can configure routes to additional networks by setting an rd.route= value.


[NOTE]
----
When you configure one or multiple networks, one default gateway is required. If the additional network gateway is different from the primary network gateway, the default gateway must be the primary network gateway.
----

* To configure the default gateway, enter the following command:

```terminal
ip=::10.10.10.254::::
```

* To configure the route for an additional network, enter the following command:

```terminal
rd.route=20.20.20.0/24:20.20.20.254:enp2s0
```


### Configuring VLANs on individual interfaces

As an optional task, you can configure VLANs on individual interfaces by using the vlan= parameter.

* To configure a VLAN on a network interface and use a static IP address, run the following command:

```terminal
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:enp2s0.100:none
vlan=enp2s0.100:enp2s0
```

* To configure a VLAN on a network interface and to use DHCP, run the following command:

```terminal
ip=enp2s0.100:dhcp
vlan=enp2s0.100:enp2s0
```


### Bonding multiple network interfaces to a single interface

As an optional task, you can bond multiple network interfaces to a single interface by using the bond= option. By completing this task, you can eliminate a single point of failure for your network environment.

The following example demonstrates editing the /etc/config/network file and specifying the following syntax for bonding multiple network interfaces to a single interface:


```terminal
bond=<name>[:<network_interfaces>][:<options>]
```


* <name>: Specifies the bonding device name, for example bond0.
* <network_interfaces>: Specifies a comma-separated list of physical (ethernet) interfaces, such as em1,em2.
* <options>: Specifies a comma-separated list of bonding options. Enter the `modinfo bonding command to see available options.

When you create a bonded interface using the bond= command, you must specify how the IP address is assigned and other information for the bonded interface.

* To configure the bonded interface to use DHCP, edit the /etc/config/network file by setting the IP address for the bond to dhcp. For example:

```terminal
bond=bond0:em1,em2:mode=active-backup
ip=bond0:dhcp
```

* To configure the bonded interface to use a static IP address, edit the /etc/config/network file entering the specific IP address you want and related information. For example:

```terminal
bond=bond0:em1,em2:mode=active-backup,fail_over_mac=1
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:bond0:none
```


Always set the fail_over_mac=1 option in active-backup mode to avoid problems when shared OSA/RoCE cards are used.
* You can configure VLANs on bonded interfaces by editing the /etc/config/network file and specifying the vlan= parameter to use DHCP. For example:

```terminal
ip=bond0.100:dhcp
bond=bond0:em1,em2:mode=active-backup
vlan=bond0.100:bond0
```

* To configure the bonded interface with a VLAN, edit the /etc/config/network file and specify a static IP address. For example:

```terminal
ip=10.10.10.2::10.10.10.254:255.255.255.0:core0.example.com:bond0.100:none
bond=bond0:em1,em2:mode=active-backup
vlan=bond0.100:bond0
```


### Using network teaming

You can use network teaming as an alternative to bonding by using the team= parameter. Consider this task for servers that need highly customizable network logic and better performance in virtualized or high-traffic environments.

1. Optional: You can use network teaming as an alternative to bonding by using the team= parameter.
* The syntax for configuring a team interface is: team=name[:network_interfaces]

name is the team device name (team0) and network_interfaces represents a comma-separated list of physical (ethernet) interfaces (em1, em2).

[NOTE]
----
Teaming is planned to be deprecated when RHCOS switches to an upcoming version of RHEL. For more information, see this Red Hat Knowledgebase Article.
----

Use the following example to configure a network team:

```terminal
team=team0:em1,em2
ip=team0:dhcp
```


# Waiting for the bootstrap process to complete

To install Red Hat OpenShift Container Platform, use Ignition configuration files to initialize the bootstrap process after the cluster nodes boot into RHCOS. You must wait for this process to complete to ensure the cluster is fully installed.

* You have created the Ignition config files for your cluster.
* You have configured suitable network, DNS, and load balancing infrastructure.
* You have obtained the installation program and generated the Ignition config files for your cluster.
* You installed RHCOS on your cluster machines and provided the Ignition config files that the Red Hat OpenShift Container Platform installation program generated.

1. Monitor the bootstrap process:

```terminal
$ ./openshift-install --dir <installation_directory> wait-for bootstrap-complete \
    --log-level=info
```


where:
<installation_directory>:: Specifies the path to the directory that stores the installation files.
--log-level=info:: Specifies warn, debug, or error instead of info to view different installation details.
Example output

```terminal
INFO Waiting up to 30m0s for the Kubernetes API at https://api.test.example.com:6443...
INFO API v1.31.3 up
INFO Waiting up to 30m0s for bootstrapping to complete...
INFO It is now safe to remove the bootstrap resources
```


The command succeeds when the Kubernetes API server signals that it has been
bootstrapped on the control plane machines.
2. After the bootstrap process is complete, remove the bootstrap machine from the
load balancer.

[IMPORTANT]
----
You must remove the bootstrap machine from the load balancer at this point. You
can also remove or reformat the bootstrap machine itself.
----

# Logging in to the cluster by using the CLI

To log in to your cluster as the default system user, export the kubeconfig file. This configuration enables the CLI to authenticate and connect to the specific API server created during Red Hat OpenShift Container Platform installation.

The kubeconfig file is specific to a cluster and is created during Red Hat OpenShift Container Platform installation.

* You deployed an Red Hat OpenShift Container Platform cluster.
* You installed the OpenShift CLI (`oc`).

1. Export the kubeadmin credentials by running the following command:

```terminal
$ export KUBECONFIG=<installation_directory>/auth/kubeconfig
```


where:
<installation_directory>:: Specifies the path to the directory that stores the installation files.
2. Verify you can run oc commands successfully using the exported configuration by running the following command:

```terminal
$ oc whoami
```

Example output

```terminal
system:admin
```


# Approving the certificate signing requests for your machines

To add machines to a cluster, verify the status of the certificate signing requests (CSRs) generated for each machine. If manual approval is required, approve the client requests first, followed by the server requests.

* You added machines to your cluster.

1. Confirm that the cluster recognizes the machines:

```terminal
$ oc get nodes
```

Example output

```terminal
NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.31.3
master-1  Ready     master  63m  v1.31.3
master-2  Ready     master  64m  v1.31.3
```


The output lists all of the machines that you created.

[NOTE]
----
The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.
----
2. Review the pending CSRs and ensure that you see the client requests with the Pending or Approved status for each machine that you added to the cluster:

```terminal
$ oc get csr
```

Example output

```terminal
NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...
```


In this example, two machines are joining the cluster. You might see more approved CSRs in the list.
3. If the CSRs were not approved, after all of the pending CSRs for the machines you added are in Pending status, approve the CSRs for your cluster machines:

[NOTE]
----
Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the machine-approver if the Kubelet requests a new certificate with identical parameters.
----

[NOTE]
----
For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the oc exec, oc rsh, and oc logs commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the node-bootstrapper service account in the system:node or system:admin groups, and confirm the identity of the node.
----
* To approve them individually, run the following command for each valid CSR:

```terminal
$ oc adm certificate approve <csr_name>
```


where:
<csr_name>:: Specifies the name of a CSR from the list of current CSRs.
* To approve all pending CSRs, run the following command:

```terminal
$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve
```


[NOTE]
----
Some Operators might not become available until some CSRs are approved.
----
4. Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:

```terminal
$ oc get csr
```

Example output

```terminal
NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...
```

5. If the remaining CSRs are not approved, and are in the Pending status, approve the CSRs for your cluster machines:
* To approve them individually, run the following command for each valid CSR:

```terminal
$ oc adm certificate approve <csr_name>
```


where:
<csr_name>:: Specifies the name of a CSR from the list of current CSRs.
* To approve all pending CSRs, run the following command:

```terminal
$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve
```

6. After all client and server CSRs have been approved, the machines have the Ready status. Verify this by running the following command:

```terminal
$ oc get nodes
```

Example output

```terminal
NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.31.3
master-1  Ready     master  73m  v1.31.3
master-2  Ready     master  74m  v1.31.3
worker-0  Ready     worker  11m  v1.31.3
worker-1  Ready     worker  11m  v1.31.3
```


[NOTE]
----
It can take a few minutes after approval of the server CSRs for the machines to transition to the Ready status.
----

# Initial Operator configuration

To ensure all Operators become available, configure the required Operators immediately after the control plane initialises. This configuration is essential for stabilizing the cluster environment following the installation.

* Your control plane has initialized.

1. Watch the cluster components come online:

```terminal
$ watch -n5 oc get clusteroperators
```

Example output

```terminal
NAME                                       VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE
authentication                             4.18.0    True        False         False      19m
baremetal                                  4.18.0    True        False         False      37m
cloud-credential                           4.18.0    True        False         False      40m
cluster-autoscaler                         4.18.0    True        False         False      37m
config-operator                            4.18.0    True        False         False      38m
console                                    4.18.0    True        False         False      26m
csi-snapshot-controller                    4.18.0    True        False         False      37m
dns                                        4.18.0    True        False         False      37m
etcd                                       4.18.0    True        False         False      36m
image-registry                             4.18.0    True        False         False      31m
ingress                                    4.18.0    True        False         False      30m
insights                                   4.18.0    True        False         False      31m
kube-apiserver                             4.18.0    True        False         False      26m
kube-controller-manager                    4.18.0    True        False         False      36m
kube-scheduler                             4.18.0    True        False         False      36m
kube-storage-version-migrator              4.18.0    True        False         False      37m
machine-api                                4.18.0    True        False         False      29m
machine-approver                           4.18.0    True        False         False      37m
machine-config                             4.18.0    True        False         False      36m
marketplace                                4.18.0    True        False         False      37m
monitoring                                 4.18.0    True        False         False      29m
network                                    4.18.0    True        False         False      38m
node-tuning                                4.18.0    True        False         False      37m
openshift-apiserver                        4.18.0    True        False         False      32m
openshift-controller-manager               4.18.0    True        False         False      30m
openshift-samples                          4.18.0    True        False         False      32m
operator-lifecycle-manager                 4.18.0    True        False         False      37m
operator-lifecycle-manager-catalog         4.18.0    True        False         False      37m
operator-lifecycle-manager-packageserver   4.18.0    True        False         False      32m
service-ca                                 4.18.0    True        False         False      38m
storage                                    4.18.0    True        False         False      37m
```

2. Configure the Operators that are not available.

## Disabling the default OperatorHub catalog sources

Operator catalogs that source content provided by Red Hat and community projects are configured for OperatorHub by default during an Red Hat OpenShift Container Platform installation.
In a restricted network environment, you must disable the default catalogs as a cluster administrator.

* Disable the sources for the default catalogs by adding disableAllDefaultSources: true to the OperatorHub object:

```terminal
$ oc patch OperatorHub cluster --type json \
    -p '[{"op": "add", "path": "/spec/disableAllDefaultSources", "value": true}]'
```



[TIP]
----
Alternatively, you can use the web console to manage catalog sources. From the Administration -> Cluster Settings -> Configuration -> OperatorHub page, click the Sources tab, where you can create, update, delete, disable, and enable individual sources.
----

## Image registry storage configuration

The Image Registry Operator is not initially available for platforms that do not provide default storage. After installation, you must configure your registry to use storage so that the Registry Operator is made available.

Configure a persistent volume, which is required for production clusters. Where applicable, you can configure an empty directory as the storage location for non-production clusters.

You can also allow the image registry to use block storage types by using the Recreate rollout strategy during upgrades.

### Configuring registry storage for IBM Z

To ensure the registry is fully operational, configure the registry to use storage immediately after the cluster installation. This configuration is a mandatory step to enable the registry to store data.

* You have access to the cluster as a user with the cluster-admin role.
* You have a cluster
on IBM Z(R).
* You have provisioned persistent storage for your cluster, such as Red Hat OpenShift Data Foundation.

[IMPORTANT]
----
Red Hat OpenShift Container Platform supports ReadWriteOnce access for image registry storage when you have only one replica. ReadWriteOnce access also requires that the registry uses the Recreate rollout strategy. To deploy an image registry that supports high availability with two or more replicas, ReadWriteMany access is required.
----
* You must have a system with at least 100Gi capacity.

1. To configure your registry to use storage, change the spec.storage.pvc in
the configs.imageregistry/cluster resource.

[NOTE]
----
When you use shared storage, review your security settings to prevent outside access.
----
2. Verify that you do not have a registry pod:

```terminal
$ oc get pod -n openshift-image-registry -l docker-registry=default
```

Example output

```terminal
No resources found in openshift-image-registry namespace
```


[NOTE]
----
If you do have a registry pod in your output, you do not need to continue with this procedure.
----
3. Check the registry configuration:

```terminal
$ oc edit configs.imageregistry.operator.openshift.io
```

Example output

```yaml
storage:
  pvc:
    claim:
```


Leave the claim field blank to allow the automatic creation of an
image-registry-storage PVC.
4. Check the clusteroperator status:

```terminal
$ oc get clusteroperator image-registry
```

Example output

```terminal
NAME             VERSION              AVAILABLE   PROGRESSING   DEGRADED   SINCE   MESSAGE
image-registry   4.18                 True        False         False      6h50m
```

5. Ensure that your registry is set to managed to enable building and pushing of images.
* Run:

```
$ oc edit configs.imageregistry/cluster
```


Then, change the line

```
managementState: Removed
```


to

```
managementState: Managed
```


### Configuring storage for the image registry in non-production clusters

You must configure storage for the Image Registry Operator. For non-production clusters, you can set the image registry to an empty directory. If you do so, all images are lost if you restart the registry.

* To set the image registry storage to an empty directory:

```terminal
$ oc patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"storage":{"emptyDir":{}}}}'
```


[WARNING]
----
Configure this option only for non-production clusters.
----

If you run this command before the Image Registry Operator initializes its
components, the oc patch command fails with the following error:

```terminal
Error from server (NotFound): configs.imageregistry.operator.openshift.io "cluster" not found
```


Wait a few minutes and run the command again.

# Completing installation on user-provisioned infrastructure

To finalize the installation on user-provisioned infrastructure, complete the cluster deployment after configuring the Operators. This ensures the cluster is fully operational on the infrastructure that you provide.

* Your control plane has initialized.
* You have completed the initial Operator configuration.

1. Confirm that all the cluster components are online with the following command:

```terminal
$ watch -n5 oc get clusteroperators
```

Example output

```terminal
NAME                                       VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE
authentication                             4.18.0    True        False         False      19m
baremetal                                  4.18.0    True        False         False      37m
cloud-credential                           4.18.0    True        False         False      40m
cluster-autoscaler                         4.18.0    True        False         False      37m
config-operator                            4.18.0    True        False         False      38m
console                                    4.18.0    True        False         False      26m
csi-snapshot-controller                    4.18.0    True        False         False      37m
dns                                        4.18.0    True        False         False      37m
etcd                                       4.18.0    True        False         False      36m
image-registry                             4.18.0    True        False         False      31m
ingress                                    4.18.0    True        False         False      30m
insights                                   4.18.0    True        False         False      31m
kube-apiserver                             4.18.0    True        False         False      26m
kube-controller-manager                    4.18.0    True        False         False      36m
kube-scheduler                             4.18.0    True        False         False      36m
kube-storage-version-migrator              4.18.0    True        False         False      37m
machine-api                                4.18.0    True        False         False      29m
machine-approver                           4.18.0    True        False         False      37m
machine-config                             4.18.0    True        False         False      36m
marketplace                                4.18.0    True        False         False      37m
monitoring                                 4.18.0    True        False         False      29m
network                                    4.18.0    True        False         False      38m
node-tuning                                4.18.0    True        False         False      37m
openshift-apiserver                        4.18.0    True        False         False      32m
openshift-controller-manager               4.18.0    True        False         False      30m
openshift-samples                          4.18.0    True        False         False      32m
operator-lifecycle-manager                 4.18.0    True        False         False      37m
operator-lifecycle-manager-catalog         4.18.0    True        False         False      37m
operator-lifecycle-manager-packageserver   4.18.0    True        False         False      32m
service-ca                                 4.18.0    True        False         False      38m
storage                                    4.18.0    True        False         False      37m
```


Alternatively, the following command notifies you when all of the clusters are available. The command also retrieves and displays credentials:

```terminal
$ ./openshift-install --dir <installation_directory> wait-for install-complete
```


where:
<installation_directory>:: Specifies the path to the directory that you
stored the installation files in.
Example output

```terminal
INFO Waiting up to 30m0s for the cluster to initialize...
```


The command succeeds when the Cluster Version Operator finishes deploying the
Red Hat OpenShift Container Platform cluster from Kubernetes API server.

[IMPORTANT]
----
* The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending node-bootstrapper certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for Recovering from expired control plane certificates for more information.
* It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.
----
2. Confirm that the Kubernetes API server is communicating with the pods.
1. To view a list of all pods, use the following command:

```terminal
$ oc get pods --all-namespaces
```

Example output

```terminal
NAMESPACE                         NAME                                            READY   STATUS      RESTARTS   AGE
openshift-apiserver-operator      openshift-apiserver-operator-85cb746d55-zqhs8   1/1     Running     1          9m
openshift-apiserver               apiserver-67b9g                                 1/1     Running     0          3m
openshift-apiserver               apiserver-ljcmx                                 1/1     Running     0          1m
openshift-apiserver               apiserver-z25h4                                 1/1     Running     0          2m
openshift-authentication-operator authentication-operator-69d5d8bf84-vh2n8        1/1     Running     0          5m
```

2. View the logs for a pod that is listed in the output of the previous command by using the following command:

```terminal
$ oc logs <pod_name> -n <namespace>
```


where:
<namespace>:: Specifies the pod name and namespace, as shown in the output of an earlier command.

If the pod logs display, the Kubernetes API server can communicate with the cluster machines.
3. For an installation with Fibre Channel Protocol (FCP), additional steps are required to enable multipathing. Do not enable multipathing during installation.

See "Enabling multipathing with kernel arguments on RHCOS" in the Postinstallation machine configuration tasks documentation for more information.
4. Register your cluster on the Cluster registration page.

If you have enabled secure boot during the Red Hat OpenShift Container Platform bootstrap process, the following verification steps are required:

1. Debug the node by running the following command:

```terminal
$ oc debug node/<node_name>
```

Example output

```terminal
chroot /host
```

2. Confirm that secure boot is enabled by running the following command. Example output states 1 if secure boot is enabled and 0 if secure boot is not enabled.

```terminal
$ cat /sys/firmware/ipl/secure
```

3. List the re-IPL configuration by running the following command:

```terminal
# lsreipl
```

Example output for an FCP disk

```terminal
Re-IPL type: fcp
WWPN: 0x500507630400d1e3
LUN: 0x4001400e00000000
Device: 0.0.810e
bootprog: 0
br_lba: 0
Loadparm: ""
Bootparms: ""
clear: 0
```

Example output for a DASD disk

```terminal
for DASD output:
Re-IPL type: ccw
Device: 0.0.525d
Loadparm: ""
clear: 0
```

4. Shut down the node by running the following command:

```terminal
sudo shutdown -h
```

5. Initiate a boot from LPAR from the Hardware Management Console (HMC). See Initiating a secure boot from an LPAR in IBM documentation.
6. When the node is back, check the secure boot status again.

* How to generate SOSREPORT within Red Hat OpenShift Container Platform version 4 nodes without SSH
* Image configuration resources (Classic)
* Remote health reporting

# Next steps

* Customize your cluster.
* If the mirror registry that you used to install your cluster has a trusted CA, add it to the cluster by configuring additional trust stores.
* Remote health reporting